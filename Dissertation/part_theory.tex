\newcommand{\epp}{\mathrel{\bigoplus}}

\chapter{Метод анализа корректности синхронизации многопоточной программы с раздельным рассмотрением потоков}
\label{chapter_theory}

\section{Основные определения}

В данной главе описывается метод анализа корректности синхронизации многопоточной программы с раздельным рассмотрением потоков.
Описание метода опирается на понятия, используемые в статической верификации. 
Основными из них являются понятия \textit{состояние программы}, \textit{достижимости} и \textit{абстракции}.
Описанию этих и других необходимых понятий посвящена данная секция.

Будем рассматривать простой императивный язык программирования, в котором поддерживаются операторы присваивания (assignment), проверки условия (assumption), захват и освобождение примитивов синхронизации (acquire/release) и создание потоков (thread\_create).
%\footnote{Реализация основана на инструменте \cpachecker, который работает с программами на языке Си}.

Параллельная программа представляется автоматом потока управления (англ. Control Flow Automaton, CFA), который состоит из множества вершин $L$  и множества соединяющих их ребер $G$ .
Множество $L$ -- это множество всех точек программы (англ. program location), множество $G \subseteq L \times Ops \times L$, где $Ops$ -- это множество всех операций программы.
Так, отдельная дуга $g \in G, g = (l_1, op, l_2)$ моделирует операцию $op$, которая выполняется в программе, когда управление переходит из точки $l_1$ в точку $l_2$.
Операция создания нового потока создает новый поток с идентификатором из множества $T$ и новый поток начинает свое выполнение из некоторой точки программы из множества $L$.
Множество всех переменных программы, которые встречаются в операциях $assignment$ и $assumption$ обозначается как $X$.
Будем считать, что переменные принимают только значения лежащие в $\mathbb{Z}$.
Подмножество $X$, которое содержит все локальные переменные программы, обозначается как $X^{local}$, а подмножество, содержащее все глобальные переменные, --  $X^{global}$. 
%(to simplify presentation all threads have the same set of local variables) 
Операции захвата и освобождения примитивов синхронизации определены над множеством специальных переменных $S: S \cap X = \emptyset$.
Далее мы будем называть примитив синхронизации, связанный с переменной $s \in S$, блокировкой $s$.
Переменные из множества $S$ принимают значения из $\mathcal{T}=T \cup \{\bot_T\}$.
При этом, $s \mapsto t, t \in T$ означает, что блокировка $s$ захвачена потоком $t$, а $s \mapsto \bot_T$ означает, что эта блокировка не захвачена.

\emph{Конкретным состоянием} параллельной программы называется четверка $(c_{pc}, c_l, c_g, c_s)$, где
\begin{enumerate}
\item Отображение $c_{pc}: T \to L$ является частичной функцией из идентификаторов потоков во множество точек программы.
Каждое такое состояние задает точку в программе, в которой находится каждый из потоков.
\item Отображение $c_l: T \to C^{local}$ является частичной функций из множества идентификаторов потоков во множество присваиваний локальным переменным их значений. $C^{local}: X^{local} \to \mathbb{Z}$ -- отображение, которое задает каждой переменной из $X^{local}$ ее значение из $\mathbb{Z}$.
\item $c_g: X^{global} \to \mathbb{Z}$ задает значения глобальных переменных программы.
\item $c_s: S \to \mathcal{T}$ задает значения блокировок. 
\end{enumerate}
Множество всех возможных конкретных состояний программы обозначим через $C$.

Отображения $c_{pc}$ и $c_l$ представляют локальные части конкретного состояния для каждого потока, а $c_g$ и $c_s$ представляют глобальную часть конкретного состояния, не зависящую от потока.
Обозначим $dom$ область определения частичной функции, например, $dom(c_{pc})=\{ t \mid \exists (t, l) \in c_{pc} \land t \in T \land l \in L \}$.
Будем использовать обозначение $\qdot$ для замены параметра, который является несущественным.
Например, предыдущее определение может быть записано следующим образом $dom(c_{pc})=\{ t \mid \exists (t, \qdot) \in c_{pc} \land t \in T\}$.

Каждое состояние $c=(c_{pc}, c_l, c_g, c_s)\in C$ должно удовлетворять условию $dom(c_{pc})=dom(c_l)$, которое означает, что области определения локальных частей состояния находятся в консистентном состоянии.
Будем использовать обозначение $dom(c)$, как область значения локальных частей состояния, то есть $dom(c)=dom(c_{pc})=dom(c_l)$.

Отношение переходов $TR \subseteq C \times G \times T \times C$ определяет преобразование конкретных состояний под действием операторов программы. 
Переход  $(c_1, g, t, c_2)$, где $c_1, c_2 \in C$ моделирует переход программы из состояния $c_1$ в состояние $c_2$ при выполнении потоком $t \in T$ операции на дуге $g \in G$.
Для наглядности будем использовать обозначение $c_1 \tc{g, t} c_2$ вместо $(c_1, g, t, c_2) \in TR$.
Для полноты будем считать, что существует специальный $\varepsilon$-переход из каждого состояния в себя:
$\forall c \in C, t \in T: c \tc{\varepsilon, t} c$.

Определим множество конкретных переходов $\mathcal{T}=C\times G \times T$.
Конкретный переход $\tau \in \mathcal{T}$ -- это тройка $\tau = (c, g, t)$. 
Будем писать $\tau_1 \tcarrow \tau_2$, если $\exists c_3 \in C: c_1 \tc{g_1, t_1} c_2 \tc {g_2, t_2} c_3$.

Для всех $c=(c_{pc}, c_l, c_g, c_s), c'=(c'_{pc}, c'_l, c'_g, c'_s) \in C$, $g = (l, \cdot, l')\in G$, $t\in T$ любой переход $c \tc{g, t} c'$ должен удовлетворять следующим требованиям:
\begin{enumerate}
\item Переход начинается в состоянии $c$: $t\in dom(c_{pc}) \land c_{pc}(t)=l$.
\item При выполнении операции поток $t$ переходит в точку $l'$: $c'_{pc}(t)=l'$.
\item Каждый переход $c \tc{g,t} c'$ может изменить только локальную часть состояния, которая соответствует потоку $t$ и, возможно, глобальную часть состояния, то есть локальные части других потоков остаются неизменны.
Формально
$\forall t'\in T: (t'\neq t) \land (t \in dom(c_{pc})\cap dom(c'_{pc})) \Rightarrow c'_{pc}(t')=c_{pc}(t') \land c'_l(t')=c_l(t')$.
\end{enumerate}

Полное отношение переходов $\tcarrow$ определяется как объединение по всем переходам: 
$\tcarrow = \displaystyle\bigcup_{g \in G,t \in T} \tc{g,t}$.
Будем обозначать $c \tc{g, t} c'$, если $(c, g, t, c') \in \tcarrow$, и
$c \tc{g} c'$, если $\exists t\in T: c \tc{g,t} c'$, и 
$c \tcarrow c'$, если $\exists g\in G: c \tc{g} c'$. 
%Подмножество $r \subseteq C$ is called region.
Конкретное состояние $c_n$ будем называть \textit{достижимым} из некоторого подмножества $r \subseteq C$ и обозначать $c_n \in Reach_{\tcarrow}(r)$, если существует последовательность конкретных состояний $\langle c_0, c_1, ..., c_n \rangle$ такая, что $c_0 \in r$ и $\forall i : 1 \leq i \leq n : c_{i-1} \tcarrow c_i$.

%define regular semantics
Обозначим через $eval(c, t, expr)$ значение выражения $expr$ над переменными из $X^{local} \cup X^{global}$ и со значениями этих переменных из конкретного состояния $c \in C$ для потока с идентификатором $t \in T$. %TODO need more?

Далее определим семантику операций в программе: оператора присваивания (assignment), оператора проверки условия (assumption), операторов захвата и освобождения блокировки (acquire/release), а также оператора порождения потока (thread\_create).
Для каждого из этих операторов необходимо задать правила преобразования конкретных состояний программы.
Далее мы не будем отдельно подчеркивать требования 1--3, которые выполняются для любого перехода.

\subsection{Оператор проверки условия}

Рассмотрим дугу CFA, которая содержит оператор проверки условия $g = (l, assume(expr), l') \in G$, $l, l' \in L$.
Переход $c \tc{g, t} c'$, $c, c' \in C, t\in T$ существует в том и только в том случае, если
\begin{itemize}
\item $c = c'$ -- переход не меняет состояние программы;
\item $eval(c, t, expr) \neq 0$ -- значение проверяемого выражение не равно нулю.
\end{itemize}

\subsection{Оператор присваивания}

Рассмотрим дугу CFA, которая содержит оператор проверки условия $g = (l, assign(x, expr), l') \in G$, $l, l' \in L$.
Переход $c \tc{g, t} c'$, $c, c' \in C, t\in T$, $c=(c_{pc}, c_l, c_g, c_s)$ существует в том и только в том случае, если
\begin{itemize}
\item $dom(c)=dom(c')$ -- переход не меняет множество активных потоков;
\item 
Переход присваивает переменной $x$ значение выражения $expr$, то есть
\begin{itemize}
\item Если $x \in X^{local}$
\begin{align*}
\forall x' \in X^{local}: c'_l(t')(x')=
\begin{cases}
eval(c, t, expr)& \text{, если $x' = x \land t' = t$} \\
c_l(t')(x') & \text{, если $x'\neq x \lor t \neq t'$}
\end{cases} 
\end{align*}
$c'_g = c_g$.

\item Если $x \in X^{global}$ 
\begin{align}
\forall x' \in X^{global}: c'_g(x')=
\begin{cases}
eval(c, t, expr)& \text{, если $x' = x$} \\
c_g(x') & \text{, если $x'\neq x$}
\end{cases} \nonumber
\end{align}
$c'_l = c_l$.
\end{itemize}

\item $c'_s = c_s$ -- блокировки не меняют свои значения.
\end{itemize}

\subsection{Операции с примитивами синхронизации}

%Используем похожее определение на то, которое было дано в~\cite{TAR}. 
Предполагаем, что операция $acquire(s)$ в потоке $t \in T$, где $s\in S$ -- блокировка, имеет следующую семантику: 
если $s \mapsto \bot_T$ в предыдущем состоянии, тогда $s \mapsto t$ в следующем состоянии, и эта операция (сравнение и изменение состояния блокировки) производится атомарно за один переход.
%This encoding is essential to prove absence of data races by thread-modular analysis as described in~\cite{}. %qader
%For example, if you use semantics $if$ $(s==0)$ $s=1$ then thread-modular approach will not work.

Формально, для дуги $g = (l, acquire(s), l') \in G$ и $t\in T$, $l, l' \in L$ существует переход
$c \tc{g, t} c'$, $c=(c_{pc}, c_l, c_g, c_s)$, $c'=(c'_{pc}, c'_l, c'_g, c'_s) \in C$
тогда и только тогда, когда 
\begin{itemize}
\item $dom(c)=dom(c')$ -- переход не меняет множество активных потоков;
\item $c'_l=c_l$ -- переход не меняет значения локальных переменных;
\item $c'_g = c_g$ -- переход не меняет значения глобальных переменных;
\item $c_s(s) = \bot_T \land c'_s(s)=t \land \forall s'\in S: s'\neq s \Rightarrow c'_s(s')=c_s(s')$ -- никакие другие блокировки не меняют свое значение.
\end{itemize}

Предполагаем, что операция $release(s)$ в потоке $t \in T$ имеет следующую семантику:
если в начальном состоянии блокировка $s \in S$ была захвачена тем же потоком, то есть $s \mapsto t$, то в следующем состоянии эта блокировка освобождается, то есть $s \mapsto \bot_T$. Операция проходит атомарно.

Формально, для дуги $g = (l, release(s), l')\in G$ и $t\in T$, $l, l' \in L$ существует переход
$c \tc{g, t} c'$, $c=(c_{pc}, c_l, c_g, c_s)$, $c'=(c'_{pc}, c'_l, c'_g, c'_s) \in C$ тогда и только тогда, когда 
\begin{itemize}
\item $dom(c)=dom(c')$ -- переход не меняет множество активных потоков;
\item $c'_l=c_l$ -- переход не меняет значения локальных переменных;
\item $c'_g = c_g$ -- переход не меняет значения глобальных переменных;
\item $c_s(s)=t \land c_s'(s)=\bot_T \land \forall s'\in S: s'\neq s \Rightarrow c'_s(s')=c_s(s')$ -- никакие другие блокировки не меняют свое значение
\end{itemize}

%define thread_create
\subsection{Создание потоков}
Определим семантику $thread\_create(l_\nu)$ таким образом: текущий поток при выполнении этого оператора переходит в следующую точку программы после $thread\_create$, а новый поток создается с новым идентификатором $\nu \in T$, который добавляется в локальную часть состояния.
Созданный поток начинает свое выполнение из точки программы $l_\nu \in L$.

Заметим, что такое определение позволяет поддерживать анализ программ с неограниченным количеством потоков, так как $thread\_create$ может встречаться в цикле.

Для дуги $g = (l, thread\_create(l_\nu), l')$ существует переход
$c \tc{g, t} c'$, $c=(c_{pc}, c_l, c_g, c_s)$, $c'=(c'_{pc}, c'_l, c'_g, c'_s) \in C$, $\nu \in T$ тогда и только тогда, когда
\begin{itemize}
\item $\nu \notin dom(c) \land dom(c') = dom(c) \cup \{ \nu\}$ -- поток с идентификатором $\nu$ добавляется во множество потоков;
\item $c'_{pc}(t)=l'$ -- счетчик команд в родительском потоке переходит на следующую команду $l'$;
\item $c'_{pc}(\nu)=l_\nu$ --  счетчик команд в дочернем потоке устанавливается в начальную позицию $l_\nu$;
\item $c'_l(\nu)=\emptyset$ -- локальные переменные созданного потока не инициализированы;
\item $c'_l(t)=c_l(t) \land c'_g = c_g \land c'_s = c_s$ -- все остальные части конкретного состояния остаются без изменений.
\end{itemize}

%TODO example
%For example, consider an edge $g = (thread\_create)$ of thread creation: 
%$(2, c_1^1, c_1^2, c_1^g) \tc{g, 1} (3, c_2^1, c_1^2, c_1^3, c_1^g)$, where the $c_1^3$ is local state of the new thread.

%TODO we demonstrate reachability on data race conditions
%interesting -- requires at least two threads

\subsection{Ошибка в программе}

%Во многих методах статической верификации используется понятие ошибочного состояния. 
%Такие методы решают задачу достижимости и пытаются доказать, что заданное ошибочное состояния недостижимо.
%Примером такого определения является использование конструкций типа assert. 
%В случае нарушения логического условия, записанного в качестве параметра, инструмент фиксирует ошибку.

Существует несколько различных вариантов определения корректности программы, в частности, определения, что является ошибкой.
Наиболее общим вариантом является использования понятия достижимости.
В этом случае при верификации программа считается корректной, если удается доказать, что все ошибочные состояния недостижимы.
Если ошибочное состояние представить как точку в программе, где стоит, например, оператор assert, то корректной можно назвать программу, в которой все логические условия, записанные в качестве параметра оператора assert, не нарушаются.

Такое определение ошибки является достаточно общим, так как позволяет сформулировать различные свойства программы, которые требуется верифицировать. 
Еще одной важной особенностью является то, что такое определение с одинаковым успехом может применяться как к последовательным программам, так и к параллельным. 

Состояние гонки обычно определяются с помощью такой конструкции, как последовательность

\begin{small}
\begin{verbatim}
variable = expression;
assert(variable == expression);
\end{verbatim}
\end{small}

Эта конструкция моделирует проверку, не может ли измениться значение переменной $variable$ в данной точке программы.
Если инструменту удается доказать, что условие оператора assert не нарушается, это будет означать, что не существует потока, который мог бы обновить значение переменной.
И наоборот, если условие нарушается, это означает, что значение переменной было изменено в параллельном потоке.

Основным минусом такого подхода является то, что при поиске состояний гонки в реальных программах не известно, какая именно переменная может модифицироваться из нескольких потоков, а значит, придется расставлять assert после каждой записи в переменную, проверяя, может ли измениться ее значение в другом потоке или нет.
Кроме того, такой подход не позволяет обнаруживать состояния гонки, в котором один из доступов является чтением.
Тем не менее, многие инструменты статической верификации используют его, как наиболее простой.
Данная теория также поддерживает такое определение, однако, для практического поиска состояний гонки нам потребуется более практичное определение.

\begin{defn}
\label{raceDef}
Определим \textbf{состояние гонки} как конкретное состояние $c$ такое, что $\exists c_1, c_2 \in C$, $g_1, g_2 \in G$, $t_1, t_2 \in T$, $t_1 \neq t_2 : c \tc{g_1, t_1} c_1 \land c \tc{g_2, t_2} c_2$ и операции $g_1, g_2$ выполняются над одной и той же глобальной переменной $x \in X^{global}$ и хотя бы одна операция является присваиванием (то есть $assign(x, expr)$).
\end{defn}

Однако, на практике нас интересуют только состояния гонки, достижимые при реальном выполнении программы, то есть, $c_1, c_2 \in Reach(\{c_0\})$.

%Note, that acquire/release operations are special ones and operate on lock variables only.


\section{Адаптивный статический анализ с абстрактными переходами}
\label{sect_cpata}

\newcommand{\update}{update}
\newcommand{\frontier}{frontier}

В классической теории~\cite{BeyerCPA07,Beyer08}, абстрактное состояние описывает некоторую совокупность конкретных состояний программы.
Рассматривая абстрактные состояния программы вместо конкретных, инструмент сокращает пространство поиска, что позволяет повысить эффективность анализа.
В предлагаемом расширении теории абстрактное состояние является частичным, то есть оно может содержать лишь часть информации о конкретных состояниях программы.
Для того, чтобы получить соответствующие ему конкретные состояния необходимо взять другие частичные абстрактные состояния.
Это является следствием того, что полное конкретное состояние может быть получено только из нескольких частичных состояний, описывающих потоки по-отдельности.
Таким образом, функция конкретизации, которая предоставляет соответствие между абстрактными состояниями и конкретными, в расширенной теории отличается от классической: она определяется на множестве абстрактных элементов.

Частичными также являются и абстрактные переходы.
Каждый абстрактный переход теперь содержит лишь ту часть информации о конкретном переходе, которая соответствует частичному абстрактному состоянию. 
Чтобы получить информацию о полном абстрактном переходе, необходимо взять несколько частичных переходов, в общем случае некоторое количество $k$.
%Поэтому анализ не может гарантировать, что последующие конкретные переходы будут достижимы за один шаг cpa-оператора transfer, так как необходимо получить $k$ отдельных частичных переходов.
%Для подхода с отдельным анализом потоков $k=2$: анализ выполняет обычный переход в потоке, а затем распространяет его на все остальные потоки в качестве перехода в окружении за один шаг. Это требует двух итераций алгоритма.

Определим формально \emph{адаптивный статический анализ с абстрактными переходами} для параллельных программ $\mathbb{D}=(D$, $\Pi$, $\tatarrow$, $merge$, $stop$, $prec$).
Он состоит из абстрактного домена $D$, 
множество точности $\Pi$, 
отношения переходов $\tatarrow$,
оператора слияния $merge$, оператора останова $stop$, оператора уточненения $prec$.
Несмотря на то, что сами операторы остались теми же, что и в классической версии теории, они претерпели некоторые изменения.
Для того чтобы различать операторы программы и операторы CPA, будем использовать термин \textit{cpa-операторы} для обозначения последних.

Рассмотрим подробно cpa-операторы, которые задают используемый CPA.

\begin{itemize}

\item \emph{Абстрактный домен}  $D=(\mathcal{T}, \mathcal{E},\conc{\cdot})$ определяется множеством $\mathcal{T}$ конкретных переходов ($\mathcal{T} \subseteq C \times G \times T$), полурешеткой $\mathcal{E}$ абстрактных переходов и функцией конкретизации $\conc{\cdot}$.
Полурешетка 
$\mathcal{E}=(E, \top, \bot, \sqsubseteq, \sqcup)$ состоит из (возможно, бесконечного) множества $E$ элементов абстрактного домена, верхнего элемента $\top \in E$, нижнего элемента $\bot \in E$, частичного порядка $\sqsubseteq \subseteq E \times E$ и функции $\sqcup:E \times E \rightarrow E$ (cpa-оператор объединения состояний).
Функция $\sqcup$ возвращает наименьший элемент решетки, который больше, чем каждый из двух ее аргументов, а символы $\top$ и $\bot$ обозначают наибольший и наименьший элемент решетки $E$ соответственно. 

Функция конкретизации $\conc{\cdot}: 2^E \rightarrow 2^\mathcal{T}$ отображает каждое множество абстрактных переходов $R \subseteq E$ на множество его значений, то есть на множество конкретных состояний программы, которое оно представляет.
Основным отличием от классической функции конкретизации – это определение на множестве абстрактных элементов.
Это объясняется тем, что суммарное знание для множества частичных состояний может быть больше, чем знание для одного частичного состояния, то есть,  
$$\forall R\subseteq E: \conc{R} \supseteq \bigcup_{e\in R}{\conc{\{e\}}}$$

Для корректности анализа программы абстрактный домен должен удовлетворять следующим требованиям:

\begin{equation}
\label{cpa_conc_eq_0}
\forall R \subseteq \overline{R} \subseteq E: \conc{R} \subseteq \conc{\overline R}
\end{equation}

\begin{equation}
\label{cpa_conc_eq_2}
\forall e, e' \in E, R \subseteq E : e \sqsubseteq e' \implies \conc{R \cup e} \subseteq \conc{R \cup e'}
\end{equation}

\item Множество \emph{точности} $\Pi$ определяет уровень детализации абстрактного домена. 
Анализ использует элементы из $\Pi$, чтобы определять различный уровень точности для различных абстрактных элементов.
Пара $(e, \pi)$ называется абстрактным элементом $e$ с точностью $\pi$.
Cpa-операторы на абстрактном домене параметризуются уровнем точности.

Для $R \subseteq E \times \Pi$ обозначаем
$\conc{R} = \conc{\bigcup_{(e,\pi)\in R}\{e\}}$.

\item Отношение переходов $\tatarrow: E\times \Pi \times 2^{E\times \Pi} \times E $ определяет для каждого частичного перехода $e$ с точностью $\pi$ и множества достигнутых частичных переходов $\widehat{R}$ следующие возможные абстрактные переходы $e'$.
Будем писать $(e, \pi) \tat{\widehat{R}} e'$, если $(e, \pi, \widehat{R}, e') \in \tatarrow$.

%TODO: do we need g,t on the arrow? 
%and $e \tatarrow (e', \pi)$ if $\exists g \in G, t \in T: e \tat{g,t} (e', \pi)$.

Обозначим $Suc(e, R) = \{e' \mid e \tat{R} e'\}$, то есть состояния достижимые из $e$, а объединение по всем состояниям из R:
$Suc(R) = \bigcup_{e \in R}{Suc(e, R)}$.

Далее нам понадобится требование на $Suc(e, R)$:
\begin{equation}
\label{eq_suc}
\begin{aligned}
& \forall R_1, R_2, \widehat{R} \subseteq E, e \in E:\\
& \conc{R_1} \subseteq \conc{R_2} \implies \conc{Suc(e, R_1) \cup \widehat{R}} \subseteq \conc{Suc(e, R_2) \cup \widehat{R}} 
\end{aligned}
\end{equation}

Обозначим $Reach^k$ как
\begin{equation}
\label{reach_k}
\begin{aligned}
& \forall R \subseteq E: Reach^0(R) = R \\
& \forall k \ge 1: Reach^{k+1}(R) = Suc(Reach^k(R)) \cup Reach^{k}(R) \\
\end{aligned}
\end{equation}

Далее мы будем писать $Reach(R) = Reach^1(R)$. 

% Легко показать следующие утверждения, которые понадобятся в дальнейшем:
% \begin{equation}
% \label{cpa_reach_dist_1}
% \forall k \ge 1, A,B \subseteq E: \\
% Reach^k(A \cup B) =  Reach^k(A) \cup Reach^k(B)
% \end{equation}
%
% \begin{equation}
% \label{cpa_reach_dist_2}
% \forall k \ge 1, A,B \subseteq E, A \subseteq B: \\
% Reach^k(A) \subseteq  Reach^k(B)
% \end{equation}

Требование к отношению переходов в классическом CPA~\cite{Beyer08} является слишком строгим.
В некоторых случаях, в частности, при анализе многопоточных программ, более эффективным является аппроксимировать переходы из $\conc{\widehat{R}}$  в несколько шагов:
\begin{itemize}
\item применение переходов из частичных состояний по отдельности;
\item применение некоторых шагов позже, например, переходов по окружению.
\end{itemize}

Требованием к отношению переходов является аппроксимация сверху множества конкретных переходов:
\begin{equation}
\label{cpa_transfer_eq}
\begin{aligned}
& \exists k \ge 1: \forall R \subseteq E \times \Pi:\\
& \conc{Reach^k(R)} \supseteq \bigcup_{\tau \in \conc{R}}{\{\tau' \mid \tau \tcarrow \tau'\}}  \\
\end{aligned}
\end{equation}

Таким образом, условие~\ref{cpa_transfer_eq} ослабляет требования на cpa-оператор $transfer$ по сравнению с классической теорией CPA.
Оно означает, что анализ может получить все конкретные переходы не за один шаг абстрактного перехода, а после $k$ шагов.
Для анализа каждого потока по-отдельности мы далее увидем, что $k=2$.
При $k=1$ условие~\ref{cpa_transfer_eq} вырождается в классическое требование на cpa-оператор  $transfer$.

%--------------------------------

\item Cpa-оператор слияния состояний $merge: E \times E \times \Pi \rightarrow E$ ослабляет второй параметр, используя информацию от первого параметра, и возвращает новое абстрактное состояние с точностью, которая передавалась, как третий параметр.
Cpa-оператор \emph{merge} должен удовлетворять следующим требованиям:
\begin{equation}
\label{cpa_merge_eq}
\begin{aligned}
&\forall e, e' \in E, \pi \in \Pi : &e' \sqsubseteq merge(e, e', \pi)
\end{aligned}
\end{equation}

\item Cpa-оператор останова $stop: E \times 2^{E \times \Pi} \times \Pi \rightarrow \mathbb{B}$ проверяет, является ли абстрактный переход, передаваемый, как первый параметр с точностью, передаваемой как третий параметр, покрытым множеством абстрактных переходов, которые передаются вторым параметром.
%Cpa-оператор останова может, например, проходить по элементам из множества $R$, который передается как второй параметр и искать такой элемент, который больше ($\sqsubset$), чем проверяемый элемент.
%, or -- if $D$ is a powerset domain\footnote{A powerset domain is an abstract domain s.t. $\tconc{e \sqcup e'}{t} = \tconc{e}{t} \cup \tconc{e'}{t}$} -- can join the elements of $R$ to check if $R$ subsumes the first parameter. 
Cpa-оператор останова должен удовлетворять следующему требованию:
\begin{equation}
\label{cpa_stop_eq}
\begin{aligned}
&\forall e \in E, R \subseteq E, \pi \in \Pi:\\
&stop(e, R, \pi) \implies\forall \hat R \subseteq E: \conc{\{e\}\cup \hat R} \subseteq \conc{R \cup \hat R}
\end{aligned}
\end{equation}

\item Функция настройки точности $prec:E \times \Pi \times 2^{E \times \Pi} \rightarrow E \times \Pi$ вычисляет новое абстрактное состояние и новую точность для данного абстрактного состояния и множества асбтрактных состояний.
Эта функция может производить ослабление абстрактного состояния.
Она должна удовлетворять следующему требованию:

\begin{equation}
\label{cpa_prec_eq}
\begin{aligned}
& \forall e, e' \in E, \pi, \pi' \in \Pi, R \subseteq E \times \Pi:\\
& (e', \pi') = prec(e, \pi, R) \implies e \sqsubseteq e'
\end{aligned}
\end{equation}

\end{itemize}

В целом, множество точности $\Pi$, cpa-оператор останова $stop$, cpa-оператор объединения $merge$, cpa-оператор настройки точности $prec$ остаются такими же, как и в классической теории CPA.

%end of CPA definition
\section{Алгоритм вычисления достижимых переходов}

Алгоритм~\ref{cpata_algorithm_ps} представляет основной алгоритм, который вычисляет множество достижимых абстрактных переходов.
Он также не претерпел никаких изменений относительно классической теории CPA за исключением расширения cpa-оператора $transfer$.
 
Описание алгоритма состоит из входных данных $Data$, описания результата $result$ и, собственно, алгоритма.

\begin{algorithm}
% Plain Algorithm
 \KwData{
 адаптивный статический анализ $\mathbb{D}=(D$, $\Pi$, $\tatarrow$, $merge$, $stop$, $prec$),
 {начальный абстрактный переход $e_0$ с точностью $\pi_0 \in \Pi$},
 {множество $reached$ элементов из $E \times \Pi$},
 {множество $waitlist$ элементов из $2^{E \times \Pi}$}
 }
\KwResult{множество достижимых состояний $reached$}
 $waitlist := \{(e_0, \pi_0)\}$\;
 $reached := \{(e_0, \pi_0)\}$\;

 \While{$waitlist \neq \emptyset$}{
  pop $(e, \pi)$ from $waitlist$\;  
  \For{$e'$ : $(e, \pi) {\color{blue} \tat{reached}} e'$ }{
   $(\widehat{e}, \widehat{\pi})=prec(e',\pi,reached)$\;
   \For{$(e'', \pi'') \in reached$}{
    $e_{new} = merge(\widehat{e}, e'', \widehat{\pi})$\;
    \If{$e_{new} \neq e''$}{
     $waitlist := waitlist \setminus \{(e'',\pi'')\} \cup \{(e_{new},\pi'')\}$\;
     $reached := reached \setminus \{(e'',\pi'')\} \cup \{(e_{new},\pi'')\}$\;
    }
   }
   \If{$!stop(\widehat{e}, reached, \widehat{\pi})$}{
    $waitlist := waitlist \cup \{(\widehat{e}, \widehat{\pi})\}$\;
    $reached := reached \cup \{(\widehat{e}, \widehat{\pi})\}$\;
   }
  }
 }%repeat

% Thin about the caption
 \caption{Алгоритм $CPA(\mathbb{D}, e_0, \pi_0)$}
 \label{cpata_algorithm_ps}
\end{algorithm} 
 
\begin{thrm}
\label{thrm_soundness}
(Soundness) Для заданного адаптивного статического анализа с частичными состояниями $\mathbb{D}$ и начального абстрактного состояния $e_0$ с точностью $\pi_0$, алгоритм $CPA$ вычисляет множество абстрактных состояний, которое аппроксимирует сверху множество достижимых конкретных состояний:

$$\conc{CPA_{PS}(\mathbb{D}, e_0, \pi_0)} \supseteq Reach_{\tcarrow}(\conc{\{e_0\}})$$

\end{thrm}

Доказательство теоремы~\ref{thrm_soundness} приведено в Приложении~\ref{sect_thrm_soundness_proof}.

\section{Конфигурация CPA}

Представление анализа в терминах cpa-операторов было разработано в качестве универсального способа для описания различных техник верификации программы.
Например, классические методы проверки моделей и методы анализа потоков данных могут быть записаны единообразно, что позволит более детально сравнить эти методы, а также оценить их эффективность в одинаковых условиях.

Другим важным следствием универсального представления становится возможность переиспользовать существующие CPA и строить новые типы анализа на их основе, в том числе, путем комбинации нескольких CPA.
При этом существующие CPA могут быть дополнены новыми вариантами cpa-операторов, которые позволят более точно настроить их параметры под конкретную задачу.

Настройка CPA, или его конфигурация, позволяет получить необходимый баланс между скоростью анализа и его точностью.
Полная конфигурация алгоритма анализа заключается в подготовке набора используемых CPA, а также в выборе нужных вариантов их cpa-операторов.

Набор различных CPA обычно представляется в виде дерева, то есть, один CPA может быть вложен в другой.
Cpa-операторы корневого CPA используются в алгоритме~\ref{cpata_algorithm_ps}.
А вложенность CPA друг в друга означает, что при использовании cpa-операторов верхнего CPA, применяются cpa-операторы и внутреннего.
При этом внутренний CPA должен гарантировать выполнение требований на свои cpa-операторы с учетом возможного влияния внутреннего CPA.
Такой способ позволяет использовать несколько различных CPA за один запуск алгоритма, что и означает композицию различных вариантов анализа.

Подход с раздельным рассмотрением потоков будет реализовывать как раз такую схему.
Соответствующий CPA (будем называть его ThreadModularCPA), который реализует всю функциональность предложенного подхода, будет внешним CPA для алгоритма построения множества достижимых состояний (алгоритм~\ref{cpata_algorithm_ps}), то есть, его cpa-операторы будут использоваться алгоритмом.
В ThreadModularCPA могут быть вложены другие CPA, на которые накладываются дополнительные требования.
Далее будет рассмотрен пример вложенного CPA -- CompositeCPA, который реализует возможность параллельной композиции различных CPA. 
В CompositeCPA может быть вложено несколько различных CPA, которые работают независимо и параллельно, то есть, соответствующие cpa-операторы вызываются независимо друг от друга.

Далее будет представлено описание ThreadModularCPA, CompositeCPA и примеры CPA, которые реализуют различные варианты анализа: анализ предикатов (PredicateCPA), анализ примитивов синхронизации (LockCPA), анализ потоков (ThreadCPA) и др.

\newcommand{\conctm}[1]{\conc{#1}_{TM}}

\section{Адаптивный статический анализ с раздельным рассмотрением потоков}
\label{sect_tm_cpa}

\subsection{Общая схема метода}

Рассмотрим простую программу, в которой всего два потока (рис.~\ref{fig:ExapmleTM}).

\begin{figure}[h]
\begin{minipage}[h]{0.45\textwidth}
\begin{verbatim}
  volatile int g = 0;
  Thread1 {
  1:  g = 1;
  2:  d = 1;
  3:  …
  }
\end{verbatim}
\end{minipage}
\hfill
\begin{minipage}[h]{0.45\textwidth}
\begin{verbatim}
  volatile int d = 0;
  Thread2 {
  4:  if (d == 1) {
  5:    g = 2;
  6:  }
  }
\end{verbatim}
\end{minipage}
\caption{Пример небольшой программы}
\label{fig:ExapmleTM}
\end{figure}

Это некоторый модельный пример, в котором используется конструкция неявной синхронизации между потоками: первый поток инициализирует некоторые данные (в данном случае, глобальную переменную g), а затем выставляет флаг, что данные готовы.
Второй поток может использовать эти данные только после выставления флага, поэтому в этом примере нет состояния гонки для переменной g.
Классические методы проверки моделей перебирают все возможные варианты чередования двух потоков.

С точки зрения инструмента статической верификации, необходимо рассмотреть полное множество состояний программы, которые возникают при всех возможных чередованиях  (рис.~\ref{img:interleavings}).

\begin{figure}[ht] 
  \centering
  \includegraphics [scale=0.7] {ExampleInterleaving2}
  \caption{Построение множества чередований}
  \label{img:interleavings}
\end{figure}

Даже в простом примере и при различных оптимизациях общее число состояний растет с катастрофической скоростью.
Происходит так называемый «комбинаторный взрыв» числа состояний, что приводит к исчерпанию ресурсов.
Таким образом, классические методы проверки моделей не могут обеспечить доказательства корректности программы.

Простые методы статического анализа пытаются вычислить аппроксимацию сверху возможных действий одного потока на другой, т.н. эффект потока.
Однако, они не способны прослеживать сложные зависимости между переменными.
Например, зависимости между глобальными переменными, которые, в свою очередь, могут быть модифицированы в других потоках.
В общем случае, это требует вычисления некоторой неподвижной точки, что является нежелательным при статическом анализе, так как значительно возрастают требования к ресурсам.
В итоге, в таких сложных случаях считается, что глобальные переменные могут принимать любые значения.
А это, в свою очередь, снижает точность анализа. 

Предлагаемый подход базируется на известной идее раздельного анализа потоков (англ. thread-modular approach).
Потоки в этом случае анализируются по-отдельности, одновременно с этим строится общее для всех потоков окружение, которое аппроксимирует сверху влияние других потоков.
Это окружение формируется на основе анализа всех потоков, так как каждый поток являются частью окружения для других потоков.
Для каждого потока определяется, как и в каких условиях он может модифицировать разделяемые данные, использовать примитивы синхронизации и выполнять иные действия, влияющие на другие потоки.
Точность анализа потока зависит от того, как точно будет сформировано окружение.
Однако, остается вопрос как эффективно вычислять и представлять окружение.

При анализе последовательных программ успешной техникой, позволяющей уменьшить число рассматриваемых состояний программы, является абстракция.
Она позволяет абстрагироваться от несущественных деталей программы и рассматривать обобщенные (абстрактные) состояния, которые могут соответствовать целому множеству реальных (конкретных) состояний программы.
Это позволяет значительно сократить пространство состояний.
Ключевой идеей предлагаемого подхода является расширение абстракции не только на состояния программы, но и на операции, то есть, переходы потока.
Настраивая уровень абстракции, можно получать варианты анализа, которые будут ближе к статическому анализу многопоточных программ, или к классической статической верификации. 

\begin{figure}[ht] 
  \centering
  \includegraphics [scale=1] {ExampleInit}
  \caption{Построение абстрактных переходов двух потоков}
  \label{img:exampleInit}
\end{figure}

Рисунок~\ref{img:exampleInit} показывает часть абстрактного графа достижимости (англ. Abstract Reachability Graph, ARG) для первого и второго потока без влияния друг на друга.
Представленный анализ основан на простом анализе явных значений, который отслеживает только явные значения переменных.
Переход содержит в себе абстрактное состояние и абстрактную операцию.
Первое абстрактное состояние содержит информацию только о значении глобальной переменной x.
Новая информация о значении переменной y появляется в дочерних элементах, после того как выполнен переход, соответствующей инициализации переменной. 

Теперь необходимо учесть влияние потоков друг на друга, то есть сформировать окружение.
Будем называть проекцией операции потока описание ее эффекта, видимого для других потоков.
Например, любые модификации локальных переменных потока не влияют на другие потоки, то есть их проекция является пустой операцией.
Модификация глобальной переменной является значимой для всех потоков, поэтому ее проекция должна совпадать с самой операцией, либо аппроксимировать ее сверху, например, теряя информацию о точном присваиваемом значении.
При этом в проекции может быть не только информация о самом действии, но и об условии на его применение к другому потоку.
Например, на рисунке~\ref{img:exampleComplete} первый поток, присваивая $g = 1$ меняет значение переменной g с нуля на единицу.
Можно представить проекцию этой операции таким образом: если значение переменной x равно нулю, то оно может быть изменено на единицу.
Иными словами, проекция состоит из двух частей: условия ее применения ($[g == 0]$) и непосредственно действия $(g \rightarrow 1)$. 

При анализе некоторого потока одновременно строится его представление для остальных в качестве окружения.
Оно состоит из набора проекций операций этого потока.
Далее каждая из этих проекций должна быть применена ко всем возможным (с учетом условий внутри проекций) состояниям других потоков.
Что, в свою очередь, может породить новые, еще не исследованные состояния, а значит, и проекции.

После построения переходов в потоках независимо друг от друга (рисунок~\ref{img:exampleInit}), для всех переходов вычисляются проекции.
Для второго потока, например, это действие, которое меняет значение переменной x значение с нуля на тройку.
Остальные действия второго потока не модифицируют глобальные переменные и не порождают значимых проекций.
Затем эта проекция применяется к каждому состоянию первого потока.
На рисунке~\ref{img:exampleComplete} приведен результат применения к первому переходу.
Также эту проекцию можно применить и ко второму, однако, никаких новых путей это не породит.
К третьему переходу первого потока применить данную проекцию нельзя, так как значение переменной x не удовлетворяет условию проекции.
Применение проекции к первому переходу порождает новый путь выполнения, который в свою очередь может породить новые проекции.

\begin{figure}[ht] 
  \centering
  \includegraphics [scale=0.7] {ExampleComplete}
  \caption{Построение абстрактных переходов двух потоков}
  \label{img:exampleComplete}
\end{figure}

На рисунке~\ref{img:exampleComplete} представлен вариант с точными проекциями, которые рассматривают переходы другого потока так, как они есть.
На рисунке представлены не все возможные проекции и порожденные ими переходы.
Например, отсутствует проекция перехода $g = 2$ второго потока. 

Для проверки возможности состояния гонки нам необходимо найти два перехода, которые модифицируют одну переменную: $g = 1$ в первом потоке и $g = 2$ во втором.
Далее, необходимо проверить, являются ли два абстрактных состояния совместными, то есть, могут ли они быть частью одного глобального состояния.
В данном случае, в частичных состояниях потока значения глобальных переменных имеют разные значения, а значит, они не могут быть частью одного глобального состояния, то есть, указанные два перехода не могут быть выполнены одновременно.
Отсюда следует, что состояние гонки отсутствует.

Предлагаемый подход предоставляет гибкие варианты конфигурации для решения каждой конкретной задачи.
Как было показано на примерах, проекции действий потока могут быть представлены более точной абстракцией или, наоборот, слишком общей.
Проекции нескольких операций могут быть объединены в одну или быть рассмотрены по-отдельности.
Это позволяет выбирать необходимый баланс между точностью и скоростью.

Рассмотрим другой вариант построения абстрактных переходов на рисунке~\ref{img:exampleComplete2}.

\begin{figure}[ht] 
  \centering
  \includegraphics [scale=0.7] {ExampleComplete2-rus}
  \caption{Построение абстрактных переходов двух потоков}
  \label{img:exampleComplete2}
\end{figure}

Здесь используется более абстрактное представление проекции, при котором несколько воздействий потока объединяются в одну проекцию (эффект от окружения).
При этом обычно теряется некоторая информация. В частности, в данном случае была потеряна информация о точном значении переменной g, и поэтому данный объединенный эффект может применяться при любых ее значениях. Это позволяет сократить число состояний для анализа.
Пример показывает, как анализ рассматривает эффекты влияния одного потока на другой, что гарантирует корректность подхода.
Более того, он показывает гибкость подхода, который позволяет варьировать уровень абстракции, например, на стадии построения проекции, выбирая уровень абстракции каждого перехода в окружении.

\subsection{Формальное описание внутреннего CPA}
 
CPA, реализующий логику анализа с раздельным рассмотрением потоков, требует некоторые дополнительные возможности от вложенных CPA. 
Поэтому прежде, чем формально описывать ThreadModularCPA, опишем расширенные требования ко вложенным CPA.
 
Определение CPA, который может быть использован внутри анализа с раздельным рассмотрением потоков, расширяется дополнительным набором cpa-операторов: $compatible_{I},$ $\cdot|_p$, $compose_I$.
Таким образом, полный набор cpa-операторов для определения CPA теперь выглядит следующим образом: $\mathbb{I}=(D_{I},$ $\Pi_{I}, \tatarrow_{I},$ $merge_{I}, stop_{I},$ $prec_{I},$ $compatible_{I},$ $\cdot|_p$, $compose_I$).
Кроме того, усиливаются требования к основным cpa-операторам.

Абстрактный домен $D_I = (\mathcal{T}_I, \mathcal{E}_I, \epp_I)$ включает в себя множество конкретных переходов $\mathcal{T}_I$, полурешетку абстрактных переходов $\mathcal{E}_I$, а вместо функции конкретизации, в отличие от обычного CPA, используется cpa-оператор композиции $\epp_I$.
Это необходимо из-за того, что для подхода с раздельным анализом потоков используется одна общая схема вычисления конкретных состояний, которая основана на этом cpa-операторе композиции. 
Поэтому от вложенных CPA требуется только определить cpa-оператор композиции, который объединяет несколько частичных переходов во множество конкретных.

Как было уже сказано, состояния и переходы являются частичными, поэтому они могут не соответствовать напрямую конкретным состояниям и переходам. Чтобы получить полный переход, нужно взять композицию множества частичных переходов, которые соответствуют всем доступным потокам. Совместные частичные переходы могут быть объединены в полный конкретный переход с помощью cpa-оператора композиции $\epp: E \times T \times 2^{E \times T} \to 2^{\mathcal{T}}$.
Он возвращает множество конкретных переходов, которое соответствует данным частичным переходам.

Основное требование к cpa-оператору $\epp_I$ состоит в том, что он должен соответствовать полурешетке. Так, если один из абстрактных переходов меньше, чем другой, то композиция с тем же множеством не должна получить большее множество конкретных переходов. 


\begin{equation}
\label{cpa_tm_epp_req_1}
\begin{aligned}
& \forall e \sqsubseteq e' \in E, e_1, \dots e_n \in E, t_0,t_1,\dots,t_n \in T, t_i \neq t_j : \\
& \epp_I
\left(
\begin{pmatrix}
e \\
t_0 
\end{pmatrix} ,
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix} ,
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right)
\subseteq \\
&\epp_I
\left(
\begin{pmatrix}
e' \\
t_0 
\end{pmatrix} ,
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right)
\end{aligned}
\end{equation}

И симметричное требование для второго аргумента:

\begin{equation}
\label{cpa_tm_epp_req_2}
\begin{aligned}
& \forall e \sqsubseteq e' \in E, e_1, \dots e_n \in E, t_0,t_1,\dots,t_n \in T, t_i \neq t_j : \\
& \epp_I
\left(
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix} ,
\left\{
\begin{pmatrix}
e \\
t_0 
\end{pmatrix} ,
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right)
\subseteq \\
&\epp_I
\left(
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix} ,
\left\{
\begin{pmatrix}
e' \\
t_0 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right)
\end{aligned}
\end{equation}

Cpa-оператор проверки совместности $compatible_I: E \times E \rightarrow \{true, false\}$ проверяет, могут ли два частичных перехода начинаться из общего полного родительского состояния. 
Этот cpa-оператор позволяет исключить из анализа те переходы, которые никак не могут выполняться параллельно друг с другом, а значит, и влиять друг на друга.

Cpa-оператор проекции $\cdot|_p: E \rightarrow E$ проецирует переход в потоке на окружение, то есть, оставляет только изменение глобального состояния программы. 
При этом точность проекции зависит от точности анализа.
Например, проекция может содержать конкретные присваиваемые значение глобальным переменным или лишь информацию, что некоторые глобальные переменные могли измениться неопределенным образом. 

$compose_I: E \times E \rightarrow E$ объединяет два абстрактных перехода в один. Он применяет абстрактную дугу из одного перехода к абстрактному состоянию другого перехода. 

В дальнейшем мы будем использовать cpa-оператор $apply_I$, как комбинацию трех cpa-операторов: $\cdot|_p$, $compose_I$ и $compatible_I$::

\begin{equation}
\label{apply_function}
\begin{aligned}
\forall e, e' \in E: apply(e, e') = 
\begin{cases}
compose_{I}(e, e'|_p), &\mbox{ если } compatible_I(e, e'|_p) \\
\bot, & \mbox{ иначе}
\end{cases}
\end{aligned}
\end{equation}

Таким образом, cpa-оператор $apply$ означает, что переходы могут быть объединены, только если они совместны. Результатом применения cpa-оператора является новый переход, который будем называть переходом в окружении, так как он представляет собой эффект окружения.

Cpa-оператор $apply$ связан с cpa-оператором $transfer_I$, поэтому отдельного условия на него нет.
Тем не менее, в дальнейшем будет описано явное условие~\ref{cpa_transfer_inner_req}, связывающее cpa-операторы $apply$ и $transfer_I$.
%Требование~\ref{cpa_transfer_tm_req} является более строгим и влечет за собой выполнение~\ref{cpa_transfer_eq}.
%Таким образом, CPA удовлетворяют общим условиям.


\subsection{Алгоритм построения окружения потока в терминах CPA}

Определим специальный CPA, который реализует логику отдельного анализа с раздельным рассмотрением потоков, в частности алгоритм построения окружения потока: $\mathbb{TM}=(D_{TM}, \Pi_{TM}, \tatarrow_{TM}, merge_{TM}, stop_{TM}, prec_{TM})$, который основан на внутреннем CPA $\mathbb{I}=(D_{I}, \Pi_{I}, \tatarrow_{I}, merge_{I}, stop_{I}, prec_{I}, compatible_{I},$ $\cdot|_p,$ $compose_I$).

\begin{enumerate}

\item Абстрактный домен $D_{TM}=(\mathcal{T}, \mathcal{E}, \conctm{\cdot})$.

Полурешетка $\mathcal{E}=\mathcal{E}_I$ эквивалентна полурешетке внутреннего анализа.
Функция конкретизации $\conc{\cdot}$ выражается через cpa-оператор композиции:

\begin{equation}
\label{cpa_conc_tm_def}
\begin{aligned}
& \forall R \subseteq E: \conctm{R} = \\ & \bigcup_{k=1}^{\infty}{ 
\bigcup_{
\begin{array}{c}
e_0, e_1,\dots,e_k \in R \\
t_0, t_1,\dots,t_k \in T
\end{array}
} {
\epp_I
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_k \\
t_k 
\end{pmatrix}
\right\}
\right)
}
}
\end{aligned}
\end{equation}

Таким образом, множество конкретных состояний получается композицией всех возможных подмножеств из частичных состояний.
Такое определение необходимо для потенциально бесконечных конкретных состояний, которые успешно поддерживаются с помощью конечных абстрактных состояний.
%Such complicated definition is needed for potentially infinite concrete states, which are successfully hold with finite abstract states. Do not replace with sets!
Покажем, что при выполнении~\ref{cpa_tm_epp_req_1},~\ref{cpa_tm_epp_req_2} требования \ref{cpa_conc_eq_0}, \ref{cpa_conc_eq_2} выполнены.

\begin{proof}

Предположим, что $R \subseteq R' \subseteq E$

\begin{align*}
\conctm{R} = \bigcup_{k}{
\bigcup_{
\begin{array}{c}
e_0, \dots,e_k \in R \\
t_0, \dots,t_k \in T
\end{array}
}{ 
\epp_I
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_k \\
t_k 
\end{pmatrix}
\right\}
\right)
}
} \subseteq  \\
\subseteq \bigcup_{k}{
\bigcup_{
\begin{array}{c}
e_0, \dots,e_k \in \overline{R} \\
t_0, \dots,t_k \in T
\end{array}}{
\epp_I
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_k \\
t_k 
\end{pmatrix}
\right\}
\right) 
}
} = \conctm{R'} 
\end{align*}

Теперь предположим, что $e \sqsubseteq e' \in E, R \subseteq E$
\begin{align*}
& \conctm{R \cup \{e\}} = \\
& \bigcup_{k}{
\bigcup_{
\begin{array}{c}
e_0, \dots,e_k \in R \cup \{e\} \\
t_0, \dots,t_k \in T
\end{array}
}{ 
\epp_I
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_k \\
t_k 
\end{pmatrix}
\right\}
\right)
}
} \subseteq \\
& \subseteq (req.~\ref{cpa_tm_epp_req_1},~\ref{cpa_tm_epp_req_2}) \subseteq \\
& \subseteq \bigcup_{k}{
\bigcup_{
\begin{array}{c}
e_0, \dots,e_k \in R \cup \{e'\} \\
t_0, \dots,t_k \in T
\end{array}
}{ 
\epp_I
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_k \\
t_k 
\end{pmatrix}
\right\}
\right)
}
} = \\
& = \conctm{R \cup \{e'\}}
\end{align*}
\end{proof}

\item Отношение переходов определяет следующие переходы, после чего применяет все достигнутые переходы, как переходы в окружении, к новым переходам, а новые переходы, как переходы в окружении, -- к уже достижимым.
Отношение перехода $transfer$ представлено на алгоритме~\ref{cpata_transfer}.

\begin{algorithm}
% Thread-modular transfer 
 \KwData{
 {начальный переход $e_0$ с точностью $\pi_0 \in \Pi$}
 }
\KwResult{множество следующих переходов $result$}
 $result := \emptyset$ \;
 
 \For{each $\widehat{e} : e_0 \tat{R}_{I} \widehat{e}$ }{
  $result := result \cup \{\widehat{e}\}$ \;
  
  \For {each $e' \in reached$} {
    $result := result \cup \{apply(e', \widehat{e})\}$ \;
    $result := result \cup \{apply(\widehat{e}, e')\}$ \;
  }
  
 }%repeat
  \Return result

 \caption{$transfer_{TM}(e_0, \pi_0, reached)$}
 \label{cpata_transfer}
\end{algorithm}

Нужно доказать, что такой cpa-оператор $transfer$ удовлетворяет условию~\ref{cpa_transfer_eq}.
Для этого нам потребуется более сложное условие, связывающее cpa-операторы внутреннего CPA~\ref{cpa_transfer_inner_req}:

\begin{equation}
\begin{aligned}
\label{cpa_transfer_inner_req}
& \forall \tau, \tau' \in \mathcal{T}, R \subseteq E: \tau \tcarrow \tau', \forall e_0, e_1, \dots, e_n \in R: e_i = (s_i, q_i) \\
& \left(
\begin{array}{ll}
& \exists t_0, t_1, \dots, t_n \in T, t_i \neq t_j, t_0 = t \\
& \tau \in \epp_I
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix} ,
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right)
\end{array}
\right) \Rightarrow \\
& \left[ \begin{array}{ll}
\lor q_0 & \neq thread\_create \land \\
& \exists e'_0, e'_1, \dots, e'_n \in E, \forall 1 \leq i \leq n: e_i \tat{R} e'_i: \\
& \exists 1 \le k \le n: t_k = t' \land \\
& \tau' \in \epp_I((e_k', t_k), \{(\tilde{e}_i, t_i) \mid \tilde{e}_i = apply(e_i', e'_k) \land i \neq k)\}) \\
\lor q_0 & = thread\_create \land \\
& \exists e'_0, e'_1, \dots, e'_{n+1} \in E, \forall 1 \leq i \leq n: e_i \tat{R} e'_i \land e_0 \tat{R} e'_{n+1}: \\
& \exists 1 \le k \le n + 1: t_k = t' \land \\
& \tau' \in \epp_I((e_k', t_k), \{(\tilde{e}_i, t_i) \mid \tilde{e}_i = apply(e_i', e'_k) \land i \neq k)\}) 
\end{array} 
\right.
\end{aligned}
\end{equation}

\begin{proof}
Действительно, рассмотрим случайный переход $\tau \tcarrow \tau'$, $\tau \in \conc{R}$.
Нужно показать, что $\exists k: \tau' \in Reach^k(R)$.
Так как $\tau \in \conc{R}$ по определению $\conc{R}$~\ref{cpa_conc_tm_def} это означает, что $\exists t, t_1, \dots, t_n \in T, t_i \neq t_j, e_0, e_1, \dots, e_n \in R:$\\
$\tau \in \epp_I
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix} ,
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right)$.

По условию на внутренние cpa-операторы~\ref{cpa_transfer_inner_req} это означает, что найдутся такие элементы $e'_0, e'_1, \dots, e'_n \in E$, которые могут быть получены за два шага: 
\begin{enumerate}
\item применение cpa-оператора $transfer$ и cpa-оператора $apply$ для перехода в текущем потоке;
\item применение cpa-оператора $transfer$ к переходам в окружении, которые были получены на предудыщем шаге с помощью cpa-оператора $apply$.
\end{enumerate}
\end{proof}
И для этих элементов $e'_0, e'_1, \dots, e'_n$ будет выполнено $\tau' \in \epp_I((e_i', t_i), \{(e_0', t_0), \dots, (e_n', t_n)\})$.
То есть, показано, что $\exists k=2: \tau' \in Reach^k(R)$.

\item $\Pi_{TM} = \Pi_{I}$
\item $merge_{TM} = merge_{I}$.
\item $stop_{TM} = stop_{I}$.
\item $prec_{TM} = prec_{I}$.

Для cpa-операторов $merge$, $stop$, $prec$ требования для внутреннего анализа совпадают с требованиями~\ref{cpa_merge_eq},~\ref{cpa_stop_eq},~\ref{cpa_prec_eq}.
\end{enumerate}

\subsection{Использование явного вида переходов}
\label{subsect_transitions}

Описанный в предыдущих разделах вариант анализа является достаточно общим. 
В различных CPA, применяемых на практике, вид абстрактного перехода зачастую может быть явно разделен на абстрактное состояние и на абстрактную дугу.
В этом случае, можно упростить описание этого анализа, используя явное разделение перехода на две части, каждая из которых отображается на свои подмножества конкретных элементов.
В этом разделе опишем общие свойства для такого варианта CPA, чтобы в дальнейшем не повторять их для каждого варианта анализа.

Итак, предположим, что полурешетка конкретных переходов $\mathcal{E}_I$ состоит из двух частей: $\mathcal{E}_I = \mathcal{E}^S_I \times \mathcal{E}^T_I$.
Это означает, что множество элементов также состоит из двух частей $E_I = E^S_I \times E^T_I$, $\top_I = \{\top^S_I, \top^T_I\}$, $\bot_I = \{\bot^S_I, \bot^T_I\}$, а все cpa-операторы получаются такой же композицией:\\
$\forall e, e' \in E_I, e = (s, q), e \sqsubseteq e' \iff (s \sqsubseteq s' \land q \sqsubseteq q')$, \\
$\forall e_1, e_2, e \in E_I, e = (s, q), e = e_1 \sqcup e_2 \iff (s = s_1 \sqcup s_2 \land q = q_1 \sqcup q_2)$.

Таким образом, имеют место две независимые решетки: над состояниями и над дугами.

Кроме того, множество абстрактных дуг почти всегда включает в себя конкретные дуги $g \in G$. 
То есть, $E^T_I = G \cup \mathcal{G}$, где $\mathcal{G}$ и есть множество абстрактных дуг (включая $\bot^T_I$).
При этом, для абстрактных дуг можно представить аналог конкретизации для состояний: $||\cdot||_I : E^T_I \to 2^G$.
Для корректности, должно быть обеспечены следующие условия:

\begin{equation}
\label{conc_edge_eq_1}
\begin{aligned}
\forall e, e' \in E^E_I: e \sqsubseteq e' \implies ||e||_I \subseteq ||e'||_I
\end{aligned}
\end{equation}

\begin{equation}
\label{conc_edge_eq_2}
\begin{aligned}
\forall q \in \mathcal{G}, g \in G: g \in ||q|| \implies g \sqsubseteq^E_I q
\end{aligned}
\end{equation}


Для cpa-оператора композиции $\epp_I$ почти всегда требуется вспомогательный предикат для определение совместности множества переходов $check_C: 2^{E_I} \to \mathbb{B}$, то есть могут ли указанные частичные переходы составить один глобальный переход.
Не путать с cpa-оператором $compatible_I$, который проверяет возможность того, что два различных перехода могут \textit{начинаться} из одного состояния.
Этот cpa-оператор $check_C$ может проверять соответствие перехода состоянию, то есть для некоторых типов анализа он не может быть разбит на два cpa-оператора, определенных на множестве состояний и на множестве переходов.
Тем не менее, cpa-оператор $\epp_I$ может быть представлен в виде композиции:

\begin{equation}
\label{epp_split}
\begin{aligned}
& \forall e_1, \dots, e_n \in E_I, e_i=(s_i,q_i): \\
& \epp_I
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right) = \\
& =
\begin{cases}
& \left\lbrace 
(c, g, t_0) \in \mathcal{T}
\left| 
\begin{array}{c}
c \in \epp^S_I
\left(
\begin{pmatrix}
s_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
s_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
s_n \\
t_n 
\end{pmatrix}
\right\}
\right) \\
g \in ||q_0||_I \cap ||q_1||_I \cap \dots \cap ||q_n||_I\})
\end{array}
\right.
\right\rbrace,\\
& \hspace{1cm} \mbox{if } check_C(e_0, \{e_1, \dots, e_n\})\\
& \emptyset \mbox{, otherwise}
\end{cases}
\end{aligned}
\end{equation}

При этом $\epp^S_I$ должен удовлетворять похожим условиям(\ref{cpa_tm_epp_req_1},~\ref{cpa_tm_epp_req_2}):

\begin{equation}
\label{cpa_tm_epp_split_req_1}
\begin{aligned}
& \forall s \sqsubseteq s' \in E^S_I, s_1, \dots s_n \in E^S_I, t_0,t_1,\dots,t_n \in T, t_i \neq t_j : \\
& \epp^S_I
\left(
\begin{pmatrix}
e \\
t_0 
\end{pmatrix} ,
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix} ,
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right)
\subseteq \\
&\epp^S_I
\left(
\begin{pmatrix}
e' \\
t_0 
\end{pmatrix} ,
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right)
\end{aligned}
\end{equation}

И симметричное требование для второго аргумента:

\begin{equation}
\label{cpa_tm_epp_split_req_2}
\begin{aligned}
& \forall s \sqsubseteq s' \in E^S_I, s_1, \dots s_n \in E^S_I, t_0,t_1,\dots,t_n \in T, t_i \neq t_j : \\
& \epp^S_I
\left(
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix} ,
\left\{
\begin{pmatrix}
e \\
t_0 
\end{pmatrix} ,
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right)
\subseteq \\
&\epp^S_I
\left(
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix} ,
\left\{
\begin{pmatrix}
e' \\
t_0 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right)
\end{aligned}
\end{equation}

Из условий~\ref{conc_edge_eq_1},~\ref{conc_edge_eq_2},~\ref{cpa_tm_epp_split_req_1},~\ref{cpa_tm_epp_split_req_2} следуют условия~\ref{cpa_tm_epp_req_1},~\ref{cpa_tm_epp_req_2}, так как множества конкретных состояний и абстрактных дуг только расширяются.

Нужно отметить, что разбить cpa-оператор $\epp^S_I$ по аналогии с cpa-оператором $\epp^E_I$ невозможно, так как уже существуют варианты анализа, которые используют иформацию о других частичных состояниях. 
Хотя таких видов анализа очень мало. 

Как уже было упомянуто, вспомогательный cpa-оператор $check_C$ в общем случае не может быть разбит на две части, однако, часто он может быть представлен через cpa-оператор проекции следующим образом: 

\begin{equation}
\label{default_check_c_def}
\begin{aligned}
& \forall e_1, \dots, e_n \in E_I, e_i=(s_i,q_i): \\
& check_C(e_0, \{e_1, \dots, e_n\}) = \\
& check^S_C(s_0, \{s_1, \dots, s_n\}) \land (\forall 1 \le i \le n, e_0|_p = (\overline{s}, \overline{q}), \overline{q} \sqsubseteq q_i)
\end{aligned}
\end{equation}

Представление~\ref{default_check_c_def} означает, что анализ не отслеживает соответствие состояний переходам. 
В этом случае, состояния должны быть совместными, а от абстрактных дуг требуется, чтобы переходы в окружении соответствовали исходному переходу в потоке. 

Если переход разбивается на две части, то cpa-оператор $compose_I$ становится тривиальным:
\begin{equation}
\label{default_compose_def}
\begin{aligned}
\forall e, e' \in E_I, e = (s, q), e' = (s', q'): compose_I(e, e') = \tilde{e} = (s, q')
\end{aligned}
\end{equation}

Cpa-оператор $compatible_I$ проверяет возможность параллельного выполнения различных переходов из частичных состояний, поэтому обычно имеет место такое выражение:

\begin{equation}
\label{default_compatible_def}
\begin{aligned}
\forall e, e' \in E_I, e = (s, q), e' = (s', q'): compatible_I(e, e') = check^S_C(s, {s'})
\end{aligned}
\end{equation}


\subsection{Анализ, инвариантный к эффектам окружения}
\label{sect_inv_analysis}

Анализ $\mathbb{I}$ будем называть инвариантным к эффектам окружения, если $\forall e, e' \in E, R \subseteq E, \widehat{e} = apply_I(e, e'): \widehat{e} = \bot \lor \widehat{e} \tat{R} e$.
То есть, никакие переходы, полученные применением эффектов окружения (проекций) не могут изменить текущего состояния (перехода). 
В этом случае применение эффектов окружения является бессмысленным.

Нужно заметить, что такой анализ не сводится к классическому анализу, так как по-прежнему $\forall R\subseteq E_C: \conc{R}_R \neq \bigcup_{e\in R}{\conc{e}_C}$.
Кроме того, часто может быть определен нетривиальный cpa-оператор $compatible^{I}$ внутри cpa-оператора $apply_I$. 
Это означает, что несмотря на то, что эффектны окружения этого вида анализа не могут изменить его состояние, сам он способен влиять на применение эффектов окружения на другие типы анализов, которые не являются инвариантными к эффектам окружения.

Если все используемые при анализе программы виды анализа инвариантны к эффектам окружения, это позволяет значительно повысить скорость работы, за счет применения только переходов в потоке.
При этом, как правило, теряется точность анализа, так как анализ полностью абстрагируется от поведения других потоков.

\section{Анализ с раздельным рассмотрением потоков без абстракции}

В этом разделе покажем, что в представленную теорию укладывается классический алгоритм проверки моделей, описанный в~\cite{ThreadModular03}.

Определим анализ с раздельным рассмотрением потоков с эффектами окружения, как
$\mathbb{Q}=(D_{Q}, \Pi_{Q}, \tatarrow_{Q}, merge_{Q}, stop_{Q}, prec_{Q}, compatible_{Q}, \cdot|_p, compose_Q)$.

Также как и в алгоритме~\cite{ThreadModular03} применение анализа возможно только к программам с ограниченным количеством точек создания потоков. Далее предполагаем, что программа имеет ограниченное количество потоков, которые отличаются точками в программе, обозначающих начало потока, например, для $thread\_create(pc_\nu)$ будет всегда создан поток с идентификатором $pc_\nu$.

% В анализе можно выделить отдельные элементы: абстрактные состояния и абстрактные дуги, поэтому при описании будет использовано описания подраздела~\ref{subsect_transitions}.

\begin{enumerate}

\item $D_Q=(\mathcal{T}_Q, \mathcal{E}_Q, \epp_Q)$.

$\mathcal{T}_Q=C \times G \times T$ -- все конкретные переходы программы.

$\mathcal{E}_Q=(E_Q, \top^E_Q, \bot^E_Q, \sqsubseteq^E_Q, \sqcup^E_Q)$ определен над $E_Q=\mathcal{R} \times T \times (G \cup \mathcal{G})$, где
$\mathcal{R}$ множество всех проекций конкретных состояний на некоторый поток:
$\mathcal{R} \subseteq T\times L\times C^{local} \times c_g \times c_s$, а 
$\mathcal{G}$ содержит эффекты окружения на глобальные части состояния
$\mathcal{G} \subseteq c_g \times c_s \times c_g \times c_s$.

Отметим, что кодирование элементов анализа было максимально приближено к оригинальному, описанному в статье~\cite{ThreadModular03}.
И в отдельных случаях кодирование может быть избыточно.

Для переходов определим дополнительный cpa-оператор, проверяющий, могут ли указанные частичные переходы образовывать глобальный переход:

\begin{equation}
\label{check_tm_na_def}
\begin{aligned}
& \forall e_0, \dots, e_n \in E_Q, e_i = (s_i, t_i, q_i), s_i=(\widehat{t_i},pc_i,l_i,gl_i,cs_i), t_i, \widehat{t_i} \in T\\
& check_C(e_0, \{e_1, \dots, e_n\}) = \\
& \forall 1 \le i \le n: t_i = t_0 \land \widehat{t_i} \ne \widehat{t_k} \land gl_i=gl_k \land cs_i=cs_k  \land \\
& e_0|_p = (s_p, t_p, q_p), q_p = q_i
\end{aligned}
\end{equation}

Для совместных переходов $e_1,\dots,e_n$ можно определить $\widehat{gl}=gl_i=gl_k$ и $\widehat{s}=s_i=s_k$.
Cpa-оператор композиции $\epp_Q$ можно определить с помощью cpa-оператора~\ref{check_tm_na_def}.

\begin{equation}
\label{epp_tm_na}
\begin{aligned}
& \forall e_0, \dots, e_n \in E_Q, t_i \in T, e_i = (s_i, t_i, q_i), s_i=(\widehat{t_i},pc_i,l_i,gl_i,cs_i)\\
& \epp_Q
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_k \\
t_k 
\end{pmatrix}
\right\}
\right) = \\
&\begin{cases}
&\left\lbrace\left(
\begin{array}{cc}
& (c, g, t_0) \in \mathcal{T} \\
& c = (c_{pc},c_l,c_g,c_s)
\end{array}
\left| 
\begin{array}{c}
\{t_0 \to pc_0,\dots,t_j \to pc_j\},\\
\{t_0\to l_0, \dots, t_j\to l_j\},\\
\hat{gl}, \hat s \\
g \in \econc{q_0}
\end{array}
\right.
\right)\right\rbrace \\& \hspace*{1cm} \text{, if }check_C(\{e_0,\dots,e_j\}) \\
& \emptyset \text{, otherwise}
\end{cases}
\\
\end{aligned}
\end{equation}

$\sqsubseteq_Q, \sqcup_Q$ определены как равенство соответствующих элементов, то есть 
$e_1 \sqsubseteq^E_Q e_2 \iff e_1 = e_2$, а $e_1 \neq e_2 \iff e_1 \sqcup_Q e_2 = \top^E$.
Таким образом, основные требования~\ref{cpa_tm_epp_req_1},~\ref{cpa_tm_epp_req_2} на $\epp_Q$ выполнены.

\item $\Pi_Q = \{\emptyset\}$ содержит один элемент, так как анализ не использует абстракцию.

\item
Отношение переходов $\tatarrow_Q$ содержит переход $e \tat{R}_Q e'$, $e=(s, t, q)$ если
\begin{itemize}
\item $q \in G$. Пусть $s=(t, pc, l, gl, cs)$ и существует соответствующий переход на проекциях
\begin{itemize}
\item $(\{t\to pc\}, \{t\to l\}, gl, s) \tc{g,t} (\{t\to pc'\}, \{t\to l'\}, gl', cs'))$, где $g \ne thread\_create$, тогда 
следующее состояние $s' = (t,pc',l', gl',cs')$.
\item или в случае $q=thread\_create(pc_\nu)$, $\nu=pc_\nu$, \\
$(\{t\to pc\}, \{t\to l\}, gl, cs) \tc{thread\_create(pc_\nu), t} (\{t\to pc', \nu \to pc_\nu\}, \{t\to l,\nu \to l\}, gl, cs))$, тогда 
следующее состояние либо $s' = (t,pc',gl,s)$ (родительский поток), либо $s' = (\nu,pc_\nu,gl,s)\}$ (новый поток).
\end{itemize}
\item $q=(gl, cs, gl'',cs'') \in \mathcal{G}$, $s=(t, pc, l, gl, cs)$. Тогда следующее состояние $s'=(t, pc, l, gl'', cs'')$.
\end{itemize}

Доказательство условия~\ref{cpa_transfer_inner_req}, связывающее cpa-операторы $transfer$, $\epp$ и $apply$, приведено в приложении~\ref{sect_transfer_q_proof}.

\item
$merge_Q(e_1,e_2,R) = e_2$.
Данный cpa-оператор очевидно удовлетворяет условию~\ref{cpa_merge_eq}.

\item
$stop_Q(e,R,\pi)=\exists e' \in R: e \sqsubseteq e'$.
Данный cpa-оператор очевидно удовлетворяет условию~\ref{cpa_stop_eq}.

\item
$prec_Q(e,\pi)=(e,\pi)$ (точность и состояние никогда не изменяются).
Данный cpa-оператор очевидно удовлетворяет условию~\ref{cpa_prec_eq}.

\item 
$compose_Q(e,e')=\tilde{e} = (s, t, g')$.

\item 
$e|_p = e' = (s, t, (gl, s, gl', s'))$.

\item
$compatible_Q: E_Q \times E_Q \to \mathbb{B}$ определяется, как равенство глобальных частей состояний, $compatible_Q(e,i)$ для $e=(t,pc, l, gl,s)$ и $e'=(t',gl',s',gl'',s'')$ есть    
$\forall \tau, \tau' \in E_Q, \tau_i = (e_i, t_i, q_i), e_i=(t_i,pc_i, l_i, gl_i,s_i)$ \\
$compatible_Q(\tau, \tau') = (gl=gl' \land s=s')$

\end{enumerate}

\section{Композиция различных видов анализа}
\label{sect_ccc_analysis}

Композиция различных типов анализа принципиально важна для объединения различных техник анализа программы в одном алгоритме.
CompositeCPA содержит в себе различные внутренние CPA, в которых переходы выполняются параллельно.
Таким образом, вычисляется абстракция сразу для нескольких типов анализа, что позволяет значительно увеличить точность.

Пусть имеется несколько различных видов анализа с раздельным рассмотрением потоков: $\Delta_1, \dots, \Delta_n$. 
Композиция различных видов анализа может быть представлена, как отдельный анализ $\mathscr{C}=(D_{\mathscr{C}},$ $\Pi_{\mathscr{C}}, \tatarrow_{\mathscr{C}},$ $merge_{\mathscr{C}}, stop_{\mathscr{C}},$ $prec_{\mathscr{C}},$ $\cdot|_p$, $compose_{\mathscr{C}}$, $compatible_{\mathscr{C}}$).
Каждый $\Delta_i$ реализует отдельный вид анализа. 
$\Delta_i=(D_{\Delta_i},$ $\Pi_{\Delta_i}, \tatarrow_{\Delta_i},$ $merge^E_{\Delta_i}, stop^E_{\Delta_i},$ $prec^E_{\Delta_i},$ $\cdot|_{\Delta_i}$, $compose_{\Delta_i}$, $compatible_{\Delta_i}$). 
Тогда элементы $\mathscr{C}$ выражаются через элементы $\Delta_i$ следующим образом.

\begin{itemize}

\item  $D_{\mathscr{C}} = D_{\Delta_1} \times \dots \times D_{\Delta_n}$

Это означает, что $\mathcal{T} = C \times G \times T$, $\mathcal{E}_{\mathscr{C}} = \mathcal{E}_{\Delta_1} \times \dots \times \mathcal{E}_{\Delta_n}$.
%$compatible_{\mathscr{C}}(e_1,\dots, e_m) = 
%compatible_1(e_1^1,\dots, e_m^1) \land \dots \land compatible_n(e_1^n,\dots, e_m^n)$

\begin{equation}
\label{composite_epp_def}
\begin{aligned}
& \epp_{\mathscr{C}}
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_m \\
t_m 
\end{pmatrix}
\right\}
\right) = \\
& \hspace{1cm} \epp_{\Delta_1}
\left(
\begin{pmatrix}
e^1_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e^1_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e^1_m \\
t_m 
\end{pmatrix}
\right\}
\right) \cap \dots \\
& \hspace{1cm} \dots \cap 
\epp_{\Delta_n}
\left(
\begin{pmatrix}
e^n_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e^n_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e^n_m \\
t_m 
\end{pmatrix}
\right\}
\right)  
\end{aligned}
\end{equation}

Из выполнимости условий~\ref{cpa_tm_epp_req_1},~\ref{cpa_tm_epp_req_2} для вложенных $\Delta_i$ следует выполнимость условий для $\mathscr{C}$, так как пересечение более широких множеств не может быть меньше, чем пересечение исходных множеств.

\item  $\Pi_{\mathscr{C}} = \Pi_{\Delta_1} \times \dots \times \Pi_{\Delta_n}$

\item 
Внутренние элементы $\Delta$ работают с графом потока управления, с двумя дополнительными операциями:~\footnote{Заметим, что в реализации CPAchecker уже присутствуют две дуги в ГПУ для каждого вызова функции: function summary и function entry. Поэтому вызов функции $thread\_create$ не требует изменений в ГПУ с точки зрения реализации.}
\begin{enumerate}
\item $tc_{parent}$ представляет действие $thread\_create$ в родительском потоке, а
\item $tc_{child}$ представляет действие $thread\_create$ в дочернем потоке.
\end{enumerate}

Для отношения переходов в композиции
$e \tat{R}_{\mathscr{C}} e'$, где $e = (e_1, \dots, e_n), e_i = (s_i, q_i), q_i \in G, q_i=(l,op,l')$.

\begin{itemize}
\item если $op=thread\_create(l_\nu)$, то $\forall 0 \le j \le n$ рассматриваются два перехода в родительском и в дочернем потоке
\begin{enumerate}
\item $(s_j, (l, tc_{parent}(l_\nu), l')) \tat{R}_{\Delta_j} (e_j',\pi')$,
\item $(s_j, (l, tc_{child}(l_\nu), l')) \tat{R}_{\Delta_j} (e_j',\pi')$.
\end{enumerate}
\item иначе, $e_j \tat{R}_{\Delta_j} (e_j',\pi')$.
\end{itemize}

Комбинация полученных $e_j$ в один переход CompositeCPA напрямую $e' = (e_1', \dots, e_n')$ является корректным, однако недостаточно точным для использования на практике. 
Один из внутренних CPA может получить более точную абстракцию, но за счет декартова произведения с другими анализами, он потеряет эту информацию. 
В частности, это важно для определения следующей дуги. Один из внутренних CPA может определить, что следующий переход возможен только по одной-единственной дуге, а другой внутренний CPA, не имея этой информации, очертит более широкое результирующее множество возможных следующих дуг.
В это ситуации было бы логичнее рассмотреть только одну дугу даже второму анализу.

Для этого определяется cpa-оператор усиления: $\downarrow: E_{\Delta_1} \times \dots \times E_{\Delta_n} \rightarrow E_{\mathscr{C}}$.
Как видно из определения, этот cpa-оператор зависит от конкретных видов анализа (CPA).
Предполагая, что внутренние CPA, используют явный вид переходов, описанный в~\ref{subsect_transitions}, опишем общий вид этого cpa-оператора для усиления информации о дугах.

\begin{equation}
\label{simple_strengthen_def}
\begin{aligned}
& \forall e \in E_{\mathscr{C}}, e = (e_1, \dots, e_n), \forall 1 \le i \le n: e_i = (s_i, q_i) \\
& \downarrow(e_1, \dots, e_n) = \\
& \begin{cases}
& ((s_1, g), \dots, (s_n, g)) \mbox{, если } \exists g \in G: \econc{q_1} \cap \dots \cap \econc{q_n} = \{g\} \\
& \bot \mbox{, если }: \econc{q_1} \cap \dots \cap \econc{q_n} = \emptyset \\
& (e_1, \dots, e_n) \mbox{, иначе }
\end{cases}
\end{aligned}
\end{equation}

Такое определение является самым примитивным cpa-оператором $\downarrow$, так как оно не учитывает возможности усиления ни абстрактных состояний, ни абстрактных дуг.
Такой cpa-оператор передает информацию другим cpa-операторам только о том, что существует единственная конкретная дуга, соответствующая абстрактным дугам всех внутренних CPA.
Тем не менее, возможны другие, более точные, реализации этого cpa-оператора.

Таким образом, полученные выше $e_j'$ переходы внутренних CPA комбинируются в один переход CompositeCPA с помощью cpa-оператора $\downarrow$:
$e' = \downarrow(e'_1, \dots, e'_n)$.
Для краткости далее будем обозначать $\downarrow(e'_1, \dots, e'_n) = \downarrow e'$.

Основным требованием на cpa-оператор $\downarrow$ является то, что он не должен терять конкретные переходы:

\begin{equation}
\label{cpa_strengthen_req}
\begin{aligned}
& \forall e_0, e_1, \dots, e_n \in E_{\mathscr{C}}, t_0, \dots, t_n \in T \\
& \epp_{\mathscr{C}}
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
apply_{\mathscr{C}}(e_1, e_0) \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
apply_{\mathscr{C}}(e_n, e_0) \\
t_n 
\end{pmatrix}
\right\}
\right) = \\
& \epp_{\mathscr{C}}
\left(
\begin{pmatrix}
\downarrow e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
apply_{\mathscr{C}}(\downarrow e_1, \downarrow e_0) \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
apply_{\mathscr{C}}(\downarrow e_n, \downarrow e_0) \\
t_n 
\end{pmatrix}
\right\}
\right)
\end{aligned}
\end{equation}

Доказательство того, что требование~\ref{cpa_strengthen_req} выполнено для простого cpa-оператора $\downarrow$ (определение~\ref{simple_strengthen_def}), приведено в приложении~\ref{sect_composite_strengthen_proof}.

Так как композитный анализ разбивает операцию $thread\_create$ на две дуги, требование~\ref{cpa_transfer_inner_req} трансформируется в

\begin{equation}
\label{cpa_transfer_composite_req}
\begin{aligned}
& \forall \tau, \tau' \in \mathcal{T}, R \subseteq E: \tau \tcarrow \tau', \forall e_0, e_1, \dots, e_n \in R: e_i = (s_i, q_i) \\
& \left(
\begin{array}{ll}
& \exists t_0, t_1, \dots, t_n \in T, t_i \neq t_j, t_0 = t \\
& \tau \in \epp_I
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix} ,
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right)
\end{array}
\right) \Rightarrow \\
& \left[ \begin{array}{ll}
\lor q_0 & \neq thread\_create \land \\
& \exists e'_0, e'_1, \dots, e'_n \in E, \forall 1 \leq i \leq n: e_i \tat{R} e'_i: \\
& \exists 1 \le k \le n: t_k = t' \land \\
& \tau' \in \epp_I((e_k', t_k), \{(\tilde{e}_i, t_i) \mid \tilde{e}_i = apply(e_i', e'_k) \land i \neq k)\}) \\
\lor q_0 & = thread\_create \land \\
& \exists e'_0, e'_1, \dots, e'_{n+1} \in E, \forall 0 \leq i \leq n: \\
& \begin{cases}
& (s_0, (l, tc_{parent}, l')) \tat{R} e'_0 \\
& (s_0, (l, tc_{child}, l')) \tat{R} e'_{n+1} \\
& e_i \tatarrow e'_i, \text{ если } i \neq 0
\end{cases} \\
& \exists 0 \le k \le n + 1:  t_k = t' \land\\
& \tau' \in \epp_I((e_k', t_k), \{(\tilde{e}_i, t_i) \mid \tilde{e}_i = apply(e_i', e'_k) \land i \neq k)\}) 
\end{array} 
\right.
\end{aligned}
\end{equation}
%
%\begin{equation}
%\label{transfer_tm_ir_stronger_for_inner_3}
%\begin{aligned}
%& \cdot g = thread\_join(var,num):\\
%& \exists r: t_r \notin dom(c) \land c_t(var, num) = t_r \\
%& \exists e_1', \dots,e_{r-1}', e_{r+1}', e_m' \in E:\\
%& c' \in \epp
%\begin{pmatrix}
%\begin{pmatrix}
%e_1' \\
%t_1 
%\end{pmatrix}&,
%\dots& ,
%\begin{pmatrix}
%e_{r-1}' \\
%t_{r-1} 
%\end{pmatrix},
%\begin{pmatrix}
%e_{r+1}' \\
%t_{r+1} 
%\end{pmatrix} ,
%\dots& ,
%\begin{pmatrix}
%e_m' \\
%t_m 
%\end{pmatrix}
%\end{pmatrix} \\
%& \mbox{ где } e_1',\dots,e_{r-1}', e_{r+1}', \dots e_m' \mbox{ такие, что } \\
%&\exists i_1, \dots, i_{k-1}, i_{k+1}, \dots, i_m: \\
%&
%\begin{cases}
%\forall q \neq k \land q \neq r: e_q \tat{i_q} e_q' \land i_q \in \{i \mid e_k \tat{\tau} i\} \\
%e_k \tat{\tau, tc_{parent}} e_k' \\
%e_k \tat{\tau, tc_{child}} e_{m+1}
%\end{cases}
%\end{aligned}
%\end{equation}


\item 
Cpa-оператор слияния $merge$ может определяться различными способами, в зависимости от требований к анализу.

Самый простой способ: использовать cpa-оператор $merge$ каждого из внутренних видов анализа.

$merge_{\mathscr{C}}(e_1,e_2,\pi) = (merge_{\Delta_1}(e_1^1, e_2^1,\pi), \dots, merge_{\Delta_n}(e_1^n, e_2^n,\pi))$.
В этом случае объединение переходов каждого из внутренних вариантов анализа производится независимо друг от друга.
Проверим условие~\ref{cpa_merge_eq}.
Воспользуемся тем, что внутренние CPA удовлетворяют условию~\ref{cpa_merge_eq}, то есть $\forall 1 \le i \le n: e_2^i \sqsubseteq merge_{\Delta_i}(e_1^i, e_2^i,\pi)$.
По определению решетки $\mathscr{C}$ это означает, что $(e_2^1, \dots, e_2^n) = e_2 \sqsubseteq merge_{\mathscr{C}}(e_1,e_2,\pi)$.

Такой простой вариант объединения состояний не очень эффективен, например, состояния различных потоков не всегда имеет смысл обединять.
Для этого возможно объединение состояний, если состояния некоторого вида анализа равны. 

\begin{align*}
merge_{\mathscr{C}}(e_1,e_2,\pi) =
\begin{cases}
&(e_1^1, merge_{\Delta_1}(e_1^2, e_2^2,\pi), \dots, merge_{\Delta_n}(e_1^n, e_2^n,\pi)), \\
& \hspace{1cm} \mbox{ если } e_1^1 = e_2^1 \\
& e_2, \mbox{ иначе }
\end{cases} 
\end{align*}

В таком примере состояния объединяются только при совпадении (равенстве) состояний первого анализа ($i=1$).
Очевидно, что такой вариант cpa-оператора $merge$ тоже удовлетворяет условию~\ref{cpa_merge_eq}, так как для $i = 1: e_2^1 \sqsubseteq e_2^1$.

Стоит отметить, что такой способ слияния не равносилен первому варианту при некотором cpa-операторе $merge_{\Delta_1}$.
При первом варианте, если хотя бы один анализ объединил свои состояния, возникнет новое состояние CompositeCPA. 
Во втором варианте новое состояние возникнет только при некотором условии (в данном случае $e_1^1 = e_2^1$), что не может быть выражено в терминах cpa-операторов $merge_{\Delta_i}$ первого способа.

\item 
$stop_{\mathscr{C}}(e,R,\pi)=\forall 0 \le j \le n: stop_{\Delta_j}(e_j, R_j, \pi)$, где $R_j = \{e_j \mid e \in R \land e = (\dots, e_j, \dots)\}$

Проверим условие~\ref{cpa_stop_eq} для $\mathscr{C}$.
По условию~\ref{cpa_stop_eq} для внутренних CPA выполнено $\forall 1 \le i \le n, \widehat{R_i} \subseteq E_i: \conc{\widehat{R_i} \cup \{e_i\}}_{TM} \subseteq \conc{R_i \cup \widehat{R_i}}_{TM}$.
Рассмотрим множество $\widehat{R} = \widehat{R_1} \times \dots \times \widehat{R_n} \subseteq E$. 
$\conc{\widehat{R} \cup \{e\}}_{TM} = \conc{\widehat{R_1} \cup \{e_1\}}_{TM} \cap \dots \cap \conc{\widehat{R_n} \cup \{e_n\}}_{TM} \subseteq \conc{R_1 \cup \widehat{R_1}}_{TM} \cap \dots \cap \conc{R_n \cup \widehat{R_n}}_{TM} = \conc{R \cup \widehat{R}}_{TM}$.

\item 
$prec_{\mathscr{C}}(e,\pi)=(prec_{\Delta_1}(e_1, \pi_1), \dots, prec_{\Delta_n}(e_n, \pi_n)$. Условие~\ref{cpa_prec_eq} выполнено для композитного анализа, если оно выполнено для каждого из внутренних видов анализа $\Delta_j$, так как по определению $e \sqsubseteq e' \iff \forall j: e_j \sqsubseteq e_j'$.

\item 
$compatible_{\mathscr{C}}(e_1, e_2) = compatible_{\Delta_1}(e^1_1, e^1_2) \land \dots \land compatible_{\Delta_n}(e^n_1, e^n_2)$.

\item 
$composite_{\mathscr{C}}(e_1, e_2) = (composite_{\Delta_1}(e^1_1, e^1_2), \dots, composite_{\Delta_n}(e^n_1, e^n_2))$.

\item 
$e|_{p\mathscr{C}} = (e_1|_{p\Delta_1}, \dots, e_n|_{p\Delta_n})$.

\end{itemize}

Доказательство того, что требование~\ref{cpa_transfer_inner_req} выполнено для $\mathscr{C}$, если требование~\ref{cpa_transfer_composite_req} выполнены для всех его внутренних элементов, приведено в приложении~\ref{sect_composite_transfer_proof}.

\section{Простой анализ потоков}
\label{sect_thread_analysis}
Определим анализ потоков, инвариантный к переходам по окружению, 
$\mathbb{T}=(D_{T},$ $\Pi_{T}, \tatarrow_{T},$ $merge_{T}, stop_{T},$ $prec_{T}, compatible_{T},$ $composite_{T},$ $\cdot|_p)$, который будет отслеживать идентификаторы потоков.

Анализ потоков содержит те же ограничения, что и анализ, представленный в статье~\cite{ThreadModular03}, и его применение ограничено на программы с фиксированным количеством создаваемых потоков.
Данный анализ использует в качестве идентификаторов потока точку старта нового потока, то для $thread\_create(pc_\nu)$ всегда создается поток с идентификатором $pc_\nu$.
Так, применение анализа потоков ограничивается программами, в которых в каждый момент времени может существовать только один экземпляр каждого потока.
Предполагаем, что программа имеет ограниченное количество потоков, определяемых точками создания этих потоков.
Заметим, что остальные виды анализа не ограничены количеством создаваемых потоков. 

\begin{figure}[ht] 
  \centering
  \includegraphics [scale=0.6] {SimpleThreadCPA-img}
  \caption{Иллюстрация состояний ThreadCPA}
  \label{img:SimpleThreadCPA}
\end{figure}

На рисунке~\ref{img:SimpleThreadCPA} приведена иллюстрация работы анализа потоков.
На нем изображен основной поток $t_0$, который создает два дополнительных в процессе своей работы: $t_1$ и $t_2$.
Состояния ThreadCPA содержат только информацию о том потоке, которому принадлежит данное состояние.
Состояния, принадлежащие разным потокам, являются совместными.
Очевидно, такой способ является очень неточным, так как не позволяет отличить, например, состояния до и после создания потока.
Более точные варианты анализа потока будут описаны далее, а пока формально дадим определение ThreadCPA.

Воспользуемся общим видом анализа с явным видом переходов, описанном в подразделе~\ref{subsect_transitions}.

\begin{itemize}

\item Множество абстрактных состояний $E^E_T=T \cup \{\bot^E,\top^E\}$, $\bot^E \sqsubseteq t \sqsubseteq^E \top^E$ и $t \neq t'$ $\Rightarrow$ $t \not\sqsubseteq^E t'$ для всех элементов $t, t'\in T$ 
(что означает $\bot^E \sqcup^E t = t$, $\top^E \sqcup t = \top^E$, $t \sqcup^E t' = \top^E$ для всех элементов $t,t'\in T$, $t\neq t'$).

В данном анализе требуется расширенный cpa-оператор проверки совместности:

\begin{align*}
& \forall t_0, \dots, t_j \in T: \\
& check_C((s_0, t_0), \{(s_1, t_1),\dots, (s_n,t_n)\}) = \forall i \neq j: t_i \neq t_j \land s_i \sqsubseteq t_i
\end{align*}

Cpa-оператор композиции для состояний строит множество таких конкретных состояний, которые лишь содержат требуемые идентификаторы потока, не накладывая больше никаких ограничений.

\begin{equation}
\begin{aligned}
& \forall t_1, \dots, t_n \in T: \\
& \epp^S_T
\left(
\begin{pmatrix}
s_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
s_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
s_n \\
t_n 
\end{pmatrix}
\right\}
\right) =  \\
& \begin{cases}
& \{c \in C \mid dom(c) = \{t_0, \dots, t_n\}\}, \\
& \hspace{1cm} \mbox{если } check_C((s_0, t_0), \{(s_1, t_1),\dots, (s_n,t_n)\})\\
& \emptyset \mbox{, иначе}
\end{cases}
\end{aligned}
\end{equation}

Такое определение cpa-оператора $\epp^S_T$ очевидно удовлетворяет условиям~\ref{cpa_tm_epp_split_req_1},~\ref{cpa_tm_epp_split_req_2}, так как, фактически, результат не зависит от состояний $s_i$, которые влияют только на cpa-оператор $check_C$.

Множество абстрактных дуг содержит только тождественную дугу, которая не меняет абстрактное состояние, и верхний и нижний элементы решетки: $\mathcal{G} = \{\bot^T_T, \varepsilon, \top^T_T\}$.
Cpa-оператор конкретизации для дуг является тривиальным: $\econc{\bot^T_T} = \emptyset$, $\econc{\varepsilon} = \econc{\top^T_T} = G$.

\item Множество точности не используется и состоит из одного элемента: $\Pi_T = \{\{\emptyset\}\}$.

\item Отношение переходов $\tatarrow_T$ определяет переход $e \tatarrow_T (e', \pi)$, $g=(\cdot,op,\cdot)$, если 
\begin{itemize}
\item $op\neq tc_{child}$ и $e' = (t, \top)$, то есть текущий поток не меняется.
\item $op=tc_{child}(l_\nu)$, тогда $e' = (l_\nu, \top)$, то есть текущий поток становится равным созданному.
\end{itemize}

Переход $\top \tat{\tau, g}_T (\top, \pi)$ определен для всех $g\in G$, однако на практике переход будет усилен (определение~\ref{simple_strengthen_def}) в CompositeCPA.

\item Cpa-оператор слияния не объединяет абстрактные состояния: $merge_T(e, e', \pi) = e'$. Условие~\ref{cpa_merge_eq} очевидно выполнено.

\item Cpa-оператор останова для абстрактных переходов проверяет наличие абстрактного перехода во множестве достижимых состояний: $stop_T(e, R, \pi) = (e \in R)$.
Проверим условие~\ref{cpa_stop_eq}.
Возьмем $\widehat{R} \subseteq E_T: \conc{\widehat{R} \cup e}_{TM} \subseteq \conc{\widehat{R} \cup e \cup R}_{TM} = \conc{\widehat{R} \cup R}_{TM}$.

\item Точность переходов никогда не меняется: $prec_T(e, \pi, R) = (e, \pi)$. Условие~\ref{cpa_prec_eq} выполнено, так как $e \sqsubseteq e$.

\item $\forall e_1, e_2 \in E_T, e_i = (s_i, q_i):compatible_T(e_1,e_2) = s_1 \neq s_2$.

\item Переходы являются {\em инвариантными к окружению}, то есть ни один поток не может изменить идентификатор другого потока.
Это означает, что проекцией является тождественный переход:
$(s, q)|_p = (s, \varepsilon)$.

\item Cpa-оператор $compose$ является обычным~\ref{default_compatible_def}.
\end{itemize}

Доказательство того, что определенные таким образом cpa-операторы $transfer$ и $apply$ удовлетворяют условию~\ref{cpa_transfer_composite_req}, приведено в приложении~\ref{sect_transfer_thread_proof}. 


\section{Анализ потоков с эффектами окружения}
\label{sect_thread_analysis_env}

Определим анализ потоков с эффектами окружения.
Этот CPA будет строить полный граф вызовов потоков, что позволит более точно определять совместные состояния, чем в описанном ранее простом анализе потоков (раздел~\ref{sect_thread_analysis}). 
Анализ потоков содержит те же ограничения, что и описанный ранее ThreadCPA.

\begin{figure}[ht] 
  \centering
  \includegraphics [scale=0.6] {ThreadCPAEnv-img}
  \caption{Иллюстрация состояний ThreadCPA}
  \label{img:ThreadCPAEnv}
\end{figure}

На рисунке~\ref{img:ThreadCPAEnv} приведена иллюстрация работы анализа потоков с эффектами окружения.
На нем изображен основной поток $t_0$, который создает два дополнительных в процессе своей работы: $t_1$ и $t_2$.
Для данного варианта ThreadCPA абстрактные состояния содержат не только информацию о текущем потоке, но и обо всем множестве активных потоков.
Состояния являются совместными только если они принадлежат разным потокам и их множество активных потоков совпадает.
Такой вариант анализа потоков является более точным, чем предыдущий вариант, так как он позволяет отсеивать состояния до и после создания потока.
Однако, информация обо всех потоках может быть получена только с помощью переходов в окружении.

Перейдем к формальному описанию ThreadCPA:
$\mathbb{T}_1=(D_{T_1},$ $\Pi_{T_1}, \tatarrow_{T_1},$ $merge_{T_1}, stop_{T_1},$ $prec_{T_1}, compatible_{T_1},$ $composite_{T_1},$ $\cdot|_p)$.
Для этого воспользуемся общим видом анализа с явным видом переходов, описанном в подразделе~\ref{subsect_transitions}.

\begin{itemize}

\item Множество абстрактных состояний $E^S_T = T \times 2^T \cup \{\bot^S_T,\top^S_T\}$.

 $\bot^E \sqsubseteq s \sqsubseteq^E \top^E$ и $s \neq s' \Rightarrow s \not\sqsubseteq^S_T s'$ для всех элементов $s, s'\in E^S_T$ 
(что означает $\bot^S_T \sqcup^S_T s = s$, $\top^S_T \sqcup t = \top^S_T$, $t \sqcup^S_T t' = \top^S_T$ для всех элементов $s,s'\in E^S_T$, $s\neq s'$).

В данном анализе требуется расширенный cpa-оператор проверки совместности:

\begin{align*}
& \forall t_0, \dots, t_n \in T, s_i = (\tilde{t}_i, C_i): \\
& check_C((s_0, t_0), \{(s_1, t_1),\dots, (s_n,t_n)\}) = \\
& \forall 0 \le i \le n: C_i = \{t_0, \dots, t_n\} \land \tilde{t}_i = t_i
\end{align*}

Этот cpa-оператор проверяет, что все частичные состояния содержат одинаковое множество созданных потоков $C$, каждый поток $\tilde{t}_i$ является созданным с точки зрения других потоков и среди всех состояний ни одна пара не принадлежит одному и тому же потоку.

Cpa-оператор композиции для состояний

$\forall s_1, \dots, s_n \in T:$
\begin{equation}
\begin{aligned}
& \epp^S_T
\left(
\begin{pmatrix}
s_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
s_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
s_n \\
t_n 
\end{pmatrix}
\right\}
\right) =  \\
& \begin{cases}
& \{c \in C \mid dom(c) = \{t_0, \dots, t_n\} = C_i\}, \\
& \hspace{1cm} \mbox{если } check_C((s_0, t_0), \{(s_1, t_1),\dots, (s_n,t_n)\})\\
& \emptyset \mbox{, иначе}
\end{cases}
\end{aligned}
\end{equation}

Такое определение cpa-оператора $\epp$ очевидно удовлетворяет условиям~\ref{cpa_tm_epp_split_req_1},~\ref{cpa_tm_epp_split_req_2}, так как используется плоская решетка.

Множество абстрактных дуг содержит тождественную дугу, которая не меняет абстрактное состояние, абстрактные дуги, соответсвующие созданию потока, а также верхний и нижний элементы решетки: $\mathcal{G} = \{\bot^T_T, \varepsilon, \top^T_T\} \cup \{create\} \times T$.
Cpa-оператор конкретизации для дуг является тривиальным: $\econc{\bot^T_T} = \emptyset$,  $\econc{\top^T_T} = G $, $\econc{\varepsilon} =G \setminus \{thread\_create(\cdot)\}$, $\econc{(create,t)} = thread\_create(t)$.

\item Множество точности не используется и состоит из одного элемента: $\Pi_T = \{\{\emptyset\}\}$.

\item Отношение переходов $\tatarrow_T$ определяет переход $e \tatarrow_T (e', \pi)$, где $e=(s,q)$ и $e' = (s', \top)$, если 
\begin{itemize}
\item $q \in G, q =(\cdot, op, \cdot)$
\begin{itemize}
\item $op \neq tc_{child}$, $op \neq tc_{parent}$ и $s' = s$, то есть состояние не меняется.
\item $op = tc_{parent}(l_\nu)$ $s' = (t, C \cup \{l_\nu\})$, то есть текущий поток не меняется, но новый поток добавляется во множество созданных потоков.
\item $op = tc_{child}(l_\nu)$ $s' = (l_\nu, C \cup \{l_\nu\})$, то есть новый поток становится текущим в состоянии и добавляется во множество созданных потоков.
% \item $op = thread\_join(l_\nu)$ $s' = (t, C \setminus \{l_\nu\})$, то есть текущий поток не меняется, но завершенный поток удаляется из множества созданных потоков.
\end{itemize}
\item $q=(create, t)$, тогда $s' = (t,  C \cup \{t\})$.
% \item $q=(join, t)$, тогда $s' = (t,  C \setminus \{t\})$.
\end{itemize}

Переход $\top \tat{\tau, g}_T (\top, \pi)$ определен для всех $g\in G$, однако на практике переход будет усилен (определение~\ref{simple_strengthen_def}) в CompositeCPA.

\item Cpa-оператор слияния не объединяет абстрактные состояния: $merge_T(e, e', \pi) = e'$. Условие~\ref{cpa_merge_eq} очевидно выполнено.

\item Cpa-оператор останова для абстрактных переходов проверяет наличие абстрактного перехода во множестве достижимых состояний: $stop_T(e, R, \pi) = (e \in R)$.
Проверим условие~\ref{cpa_stop_eq}.
Возьмем $\widehat{R} \subseteq E_T: \conc{\widehat{R} \cup e}_{TM} \subseteq \conc{\widehat{R} \cup e \cup R}_{TM} = \conc{\widehat{R} \cup R}_{TM}$.

\item Точность переходов никогда не меняется: $prec_T(e, \pi, R) = (e, \pi)$. Условие~\ref{cpa_prec_eq} выполнено, так как $e \sqsubseteq e$.

\item $\forall e_1, e_2 \in E_T, e_i = (s_i, q_i), s_i = (t_i, C_i):compatible_T(e_1,e_2) = t_1 \in C_2 \land t_2 \in C_1  \land t_1 \neq t_2 \land C_1 = C_2$.

\item 
%Переходы являются {\em инвариантными к окружению}, то есть ни один поток не может изменить идентификатор другого потока.
%Это означает, что проекцией является тождественный переход:
Проекцией перехода является тождественный переход, кроме перехода $thread\_create$:
$(s, q)|_p = 
\begin{cases}
&(s, (create, t)) \mbox{, если} q \in G, q = (\cdot, tc_{child}(t), \cdot) \lor q = (\cdot, tc_{parent}(t), \cdot) \\
% &(s, (join, t)) \mbox{, если} q \in G, q = (\cdot, thread_join(t), \cdot) \\
&(s, \varepsilon) \mbox{, иначе} \\
\end{cases}$.

\item Cpa-оператор $compose$ является обычным~\ref{default_compatible_def}.
\end{itemize}

Доказательство того, что определенные таким образом cpa-операторы $transfer$ и $apply$ удовлетворяют условию, приведено в разделе Приложения~\ref{sect_transfer_thread_env_proof}. 


\section{Расширенный анализ потоков, инвариантный к переходам в окружении}
\label{sect_thread_analysis_ext}

Определим анализ расширенный анализ потоков.
Этот CPA будет строить некоторое множество создаваемых потоков таким образом, что позволит более точно определять совместные состояния, чем в описанном ранее простом анализе потоков (раздел~\ref{sect_thread_analysis}). 
Однако, он не будет использовать переходы в окружении, что позволит ему оставаться инвариантным к переходам в окружении.
Анализ потоков содержит те же ограничения, что и описанный ранее ThreadCPA.

\begin{figure}[ht] 
  \centering
  \includegraphics [scale=0.6] {ThreadCPAExt-img}
  \caption{Иллюстрация состояний ThreadCPA}
  \label{img:ThreadCPAExt}
\end{figure}

На рисунке~\ref{img:ThreadCPAExt} приведена иллюстрация работы анализа потоков с эффектами окружения.
На нем изображен основной поток $t_0$, который создает два дополнительных в процессе своей работы: $t_1$ и $t_2$.
Для данного варианта ThreadCPA абстрактные состояния содержат информацию о том, какие потоки были созданы на пути к этому состоянию. 
Кроме того, хранится информация о том, находимся ли мы внутри созданного потока (C -- child), или остались внутри родительского (P -- parent).
Несмотря на то, что множество созданных потоков может быть неполным (поток $t_1$ не имеет инвормации про поток $t_2$, так как был создан раньше), такой анализ позволяет  обеспечить такую же точность как и вариант с ThreadCPA с переходами в окружении.
Основная идея проверки совместности состоит в том, что анализ, по сути, проверяет, может ли быть у двух абстрактных состояний одна общая точка ветвления (создание потока).
В предположении, что начальный поток был строго один, это позволяет обеспечить требуемую точность.

Перейдем к формальному описанию расширенного варианта ThreadCPA:
$\mathbb{T}_2=(D_{T_2},$ $\Pi_{T_2}, \tatarrow_{T_2},$ $merge_{T_2}, stop_{T_2},$ $prec_{T_2}, compatible_{T_2},$ $composite_{T_2},$ $\cdot|_p)$.
Для этого воспользуемся общим видом анализа с явным видом переходов, описанном в подразделе~\ref{subsect_transitions}.

\begin{itemize}

\item Множество абстрактных состояний $E^S_T = 2^{T \times \{Parent, Child\}}$.

$\bot^S_T=\emptyset$, $\top^S_T=T \times \{Parent, Child\}$.
 $\forall s,s' \in E^S_T, s \sqsubseteq s' \iff s \subseteq s'$.
 $\forall s,s' \in E^S_T, s \sqcup s' = s \cup s'$.

В данном анализе требуется расширенный cpa-оператор проверки совместности:

\begin{align*}
& \forall t_0, \dots, t_n \in T, s_0, \dots, s_n \in E^S_T: \\
& check_C((s_0, t_0), \{(s_1, t_1),\dots, (s_n,t_n)\}) = \\
& \forall 0 \le i, j \le n: \\
& \exists t \in T: (t, Parent) \in s_i \land (t, Child) \in s_j \lor (t, Parent) \in s_j \land (t, Child) \in s_i
\end{align*}

Cpa-оператор композиции для состояний

$\forall s_1, \dots, s_n \in T:$
\begin{equation}
\begin{aligned}
& \epp^S_T
\left(
\begin{pmatrix}
s_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
s_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
s_n \\
t_n 
\end{pmatrix}
\right\}
\right) =  \\
& \begin{cases}
& \{c \in C \mid dom(c) = \{t_0, \dots, t_n\}\}, \\
& \hspace{1cm} \mbox{если } check_C((s_0, t_0), \{(s_1, t_1),\dots, (s_n,t_n)\})\\
& \emptyset \mbox{, иначе}
\end{cases}
\end{aligned}
\end{equation}

Такое определение cpa-оператора $\epp$ очевидно удовлетворяет условиям~\ref{cpa_tm_epp_split_req_1},~\ref{cpa_tm_epp_split_req_2}, так как информация из состояния используется только для определения совместности.

Множество абстрактных дуг содержит только тождественную дугу, которая не меняет абстрактное состояние, и верхний и нижний элементы решетки: $\mathcal{G} = \{\bot^T_T, \varepsilon, \top^T_T\}$.
Cpa-оператор конкретизации для дуг является тривиальным: $\econc{\bot^T_T} = \emptyset$, $\econc{\varepsilon} = \econc{\top^T_T} = G$.

\item Множество точности не используется и состоит из одного элемента: $\Pi_T = \{\{\emptyset\}\}$.

\item Отношение переходов $\tatarrow_T$ определяет переход $e \tatarrow_T (e', \pi)$, $g=(\cdot,op,\cdot)$ и $e' = (s', \top)$, если 
\begin{itemize}
\item $op\neq tc_{child}$, $op\neq tc_{parent}$ и $s' = s$, то есть состояние не меняется.
\item $op=tc_{child}(l_\nu)$, тогда $s' = s \cup (l_\nu, Child)$.
\item $op=tc_{parent}(l_\nu)$, тогда $s' = s \cup (l_\nu, Parent)$.
\end{itemize}

Переход $\top \tat{\tau, g}_T (\top, \pi)$ определен для всех $g\in G$, однако на практике переход будет усилен (определение~\ref{simple_strengthen_def}) в CompositeCPA.

\item Cpa-оператор слияния не объединяет абстрактные состояния: $merge_T(e, e', \pi) = e'$. Условие~\ref{cpa_merge_eq} очевидно выполнено.

\item Cpa-оператор останова для абстрактных переходов проверяет наличие абстрактного перехода во множестве достижимых состояний: $stop_T(e, R, \pi) = (e \in R)$.
Проверим условие~\ref{cpa_stop_eq}.
Возьмем $\widehat{R} \subseteq E_T: \conc{\widehat{R} \cup e}_{TM} \subseteq \conc{\widehat{R} \cup e \cup R}_{TM} = \conc{\widehat{R} \cup R}_{TM}$.

\item Точность переходов никогда не меняется: $prec_T(e, \pi, R) = (e, \pi)$. Условие~\ref{cpa_prec_eq} выполнено, так как $e \sqsubseteq e$.

\item $\forall e_1, e_2 \in E_T, e_i = (s_i, q_i):compatible_T(e_1,e_2) = check_C(\{e_1, e_2\})$.

\item Переходы являются {\em инвариантными к окружению}, то есть ни один поток не может изменить идентификатор другого потока.
Это означает, что проекцией является тождественный переход:
$(s, q)|_p = (s, \varepsilon)$.

\item Cpa-оператор $compose$ является обычным~\ref{default_compatible_def}.
\end{itemize}

Доказательство того, что определенные таким образом cpa-операторы $transfer$ и $apply$ удовлетворяют условию~\ref{cpa_transfer_composite_req}, приведено в приложении~\ref{sect_transfer_thread_ext_proof}. 


%----------------------------------------------------
%----------------------------------------------------
%----------------------------------------------------
\section{Анализ точек программы}
\label{sect_location_analysis}

Определим анализ точек программы (LocationCPA), инвариантный к переходам по окружению,
$\mathbb{L}=(D_{L},$ $\Pi_{L}, \tatarrow_{L}, merge_{L}, stop_{L}, prec_{L},$ $compatible_{L},$ $\cdot|_p,$ $compose_L)$, который отвечает за синтаксическую достижимость точек программы.
Классический вариант этого анализа описан в~\cite{Beyer08}.
Расширим его компоненты для возможности его применения в анализе с раздельным рассмотрением потоков.

\begin{figure}[h]
\begin{minipage}[h]{0.3\textwidth}
\begin{verbatim}
  1: int main {
  2:   int y = 3;
  3:   int x = y + 1;
  4:   ...
  }
\end{verbatim}
\caption{Пример исходного кода}
\label{LocationCodeExample}
\end{minipage}
\hfill
\begin{minipage}{0.6\textwidth}
    \center{\includegraphics[scale=0.8]{LocationCPA-img.pdf}}
    \caption{Пример переходов LocationCPA}
    \label{img:LocationCPA}
\end{minipage}
\end{figure}

На рисунке~\ref{img:LocationCPA} представлен пример переходов для LocationCPA. 
Переходы содержат в себе абстрактное состояние и абстрактную дугу.
Абстрактное состояние обычно соответсвует узлу ГПУ, который можно условно считать соответсвующим строке исходного кода.
Но в общем случае состояние LocationCPA может соответствовать некоторому множеству узлов ГПУ.
Отличительной особенностью данного CPA является то, что именно он имеет полную информацию о возможных следующих дугах, поэтому при применении cpa-оператора $strengthen$ в CompositeCPA дуга LocationCPA будет браться за основу.
С точки зрения подхода с раздельным рассмотрением потоков данный CPA не несет никакой нагрузки, так как переходы в различных потоках могут выполняться параллельно независимо от того, в какой точке программы находятся эти потоки.
Таким образом, LocationCPA является важным служебным CPA, который обеспечивает обход ГПУ, но не влияет прямо на точность анализа.

Теперь дадим формальное определение cpa-операторам LocationCPA.
Воспользуемся общим видом анализа с явным видом переходов, описанном в подразделе~\ref{subsect_transitions}.
 
\begin{enumerate}

\item 
Множество абстрактных состояний $E^S_L$ состоит из абстрактных точек программы, которые отображаются на конкретные узлы ГПУ с помощью функции $loc: E^S_L \rightarrow 2^L$.
$\top^S_L$ означает, что анализ не может определить конкретную точку программы, формально, $loc(\top^S_L) = L$.
В общем случае анализ может работать с абстрактными точками программы, которые выражают несколько конкретных точек программы, но такой вариант является слишком общим и пока не нашел применения на практике, поэтому дальше мы будем рассматривать упрощенную вариацию этого анализа, в котором рассматриваются только одиночные точки программы: $\forall s \in E^S_L: s = \top^S_L \lor s=\bot^S_L \lor loc(s) = l \in L$.
Определенная таким образом $\mathcal{E}^S_L$ является плоской решеткой, что означает, что две различные точки программы являются несравнимыми: $l \neq l'$ $\Rightarrow$ $l \not\sqsubseteq^E l'$ для всех элементов $l, l' \in L$ 
(отсюда следует $\bot^E \sqcup^E l = l$, $\top^E \sqcup l=\top^E$, $ l\sqcup^E l' = \top^E$ для всех элементов $l,l'\in L$, $l\neq l'$), 
и

В данном анализе cpa-оператор является тривиальным, так как потоки могут находиться в любых точках программы независимо друг от друга:

\begin{align*}
& \forall s_0, \dots, s_j \in T: check_C(\{s_0, \dots, s_n,\}) \equiv true
\end{align*}

Cpa-оператор композиции для состояний

\begin{equation}
\label{location_epp_def}
\begin{aligned}
&\forall s_1, \dots, s_n \in E^S_L:\\
&\epp^S_{L}
\begin{pmatrix}
\begin{pmatrix}
s_1 \\
t_1 
\end{pmatrix}& ,
\dots& ,
\begin{pmatrix}
s_n \\
t_n 
\end{pmatrix}
\end{pmatrix} = \\
& \left\lbrace c \in C 
\left| 
\begin{array}{c}
\forall 1 \le i \le n \\
c_{pc}(t_i) = l_i \in loc(s_i) \\
dom(c_l) = \{t_1, \dots, t_n\}\\
\end{array}
\right.
\right\rbrace\\
\end{aligned}
\end{equation}

Такое определение cpa-оператора $\epp^S_{L}$ очевидно удовлетворяет условиям~\ref{cpa_tm_epp_split_req_1},~\ref{cpa_tm_epp_split_req_2}.

Множество абстрактных дуг содержит только тождественную дугу, которая не меняет абстрактное состояние, и верхний и нижний элементы решетки: $\mathcal{G} = \{\bot^T_T, \varepsilon, \top^T_T\}$.
Cpa-оператор конкретизации для дуг является тривиальным: $\econc{\bot^T_T} = \emptyset$, $\econc{\varepsilon} = \econc{\top^T_T} = G$.
Cостояния этого анализа {\em инвариантны к окружению}, то есть ни один поток не может изменить точку в программе, на которой находится другой поток.

\item Множество точности содержит только один элемент $\Pi_L = \{\{\emptyset\}\}$, так как не подразумевается применение абстракции.

\item Отношение переходов $\tatarrow_L$ содержит переход $e \tat{R}_L e'$, где $e = (s, q)$, если 
\begin{itemize}
\item $q \in G, q=(l_1,op,l_2)$, $l_1 \in loc(s)$ и
\begin{itemize}
\item $op \neq tc_{child}$ и $loc(s') = l_2$ (следующее состояние в ГПУ без учета семантики операции $op$), $g' = (l_2, op, \cdot)$ - все операции в ГПУ, которые соответствуют заданной точке программы.
\item $op=tc_{child}(l_\nu)$ и $l_2 = l_\nu$, $g' = (l_\nu, op, \cdot)$ - все операции в ГПУ, которые соответствуют заданной точке программы.
\end{itemize}
\item $q = \varepsilon$, $s'=s$, $g' = (l_2, op, \cdot)$ - все операции в ГПУ, которые соответствуют заданной точке программы.
\end{itemize}

% Есть переход $\top \tatarrow_L (\top, \pi)$.

\item Cpa-оператор слияния не объединяет элементы: $merge_L(e, e', \pi) = e'$. Очевидно, он удовлетворяет условию~\ref{cpa_merge_eq}, так как $e' \sqsubseteq e'$.

\item Cpa-оператор останова рассматривает состояния индивидуально: $stop_L(e, R, \pi) = (e \in R)$. Очевидно, он удовлетворяет условию~\ref{cpa_stop_eq}, так как
\begin{align}
&\forall e \in E, R \subseteq E, \pi \in \Pi: \nonumber \\
& (e \in R) \implies \forall \widehat{R} \subseteq E: \{e\} \cup \widehat{R} \subseteq R \cup \widehat{R} \implies \nonumber \\
& \implies (eq.\ref{cpa_conc_eq_0}) \forall \widehat{R} \subseteq E: \conctm{\{e\}\cup \widehat{R}} \subseteq \conc{R' \cup \widehat{R}}
\end{align}

\item Точность перехода никогда не изменяется: $prec_L(e, \pi, R) = (e, \pi)$.
Очевидно, он удовлетворяет условию~\ref{cpa_prec_eq}, так как $e \sqsubseteq e$.

\item Переходы являются {\em инвариантными к окружению}, то есть ни один поток не может изменить положение другого потока.
Это означает, что проекцией является тождественный переход:
$(s, q)|_p = (s, \varepsilon)$.

\item Cpa-оператор $compose$ является обычным~\ref{default_compatible_def}.

\item $\forall e_1, e_2 \in E_L, e_i = (s_i, q_i):compatible_L(e_1,e_2) \equiv true$.

\end{enumerate}

Доказательство того, что определенные таким образом cpa-операторы $transfer$ и $apply$ удовлетворяют условию~\ref{cpa_transfer_composite_req}, приведено в приложении~\ref{sect_transfer_location_proof}. 


%----------------------------------------------------
%----------------------------------------------------
%----------------------------------------------------

\section{Анализ предикатов}
\label{sect_predicate_analysis}

В этом разделе описан известный анализ предикатов (Predicate Analysis)~\cite{Beyer10} с абстрактными переходами.
Переходы анализа предикатов состоят из двух частей: абстрактного состояния и абстрактной дуги, которая может быть выражена либо обычной CFA дугой, либо логической формулой, кодирующей выполняемую операцию.
Кроме того, локальные переменные в этих формулах должны быть переименованы для избежания коллизии имен для разных потоков.

\begin{figure}[h]
\begin{minipage}[h]{0.3\textwidth}
\begin{verbatim}
  1: int main {
  2:   int y = 3;
  3:   int x = y + 1;
  4:   if (x > 0) {
  5:    ...
  6:  }
  }
\end{verbatim}
\caption{Пример исходного кода}
\label{PredicateCodeExample}
\end{minipage}
\hfill
\begin{minipage}{0.65\textwidth}
    \center{\includegraphics[scale=0.7]{PredicateCPA-img.pdf}}
    \caption{Пример переходов PredicateCPA}
    \label{img:PredicateCPA}
\end{minipage}
\end{figure}

Рисунок~\ref{img:PredicateCPA} демонстрирует пример переходов анализа предикатов. 
В абстрактном состоянии накапливается логическая формула на основе абстрактных дуг.
Эти формулы проверяются на разрешимость, и если оказывается, что построенная формула неразрешима, это означает, что данное состояние недостижимо при реальном выполнении.
Данный рисунок демонстрирует лишь общий вид анализа предикатов, и на нем не отображены переходы в окружении, построение предикатной абстракции и т.п.

Перейдем к формальному описанию PredicateCPA.
Пусть $\mathscr{P}$ -- это множество формул над переменными программы в теории без кванторов $\mathscr{T}$.
Пусть $\mathcal{P} \subseteq \mathscr{P}$ -- это множество предикатов.
Формула $\varphi$ является логической комбинацией предикатов из $\mathscr{P}$.

Пусть $v: X \to \mathbb{Z}$ является отображением из переменной в ее значение.
Определим $v \models \varphi$, где $v$ называется моделью $\varphi$.

Опредилим переименование переменных $\theta: X \to X'$, которое применимо к формулам $\theta(\varphi)$ и их моделям $\theta(v)$.
Обозначим
$$\theta_{X,i}= 
\left\lbrace\begin{array}{ll}
x \mapsto x\#i, & \mbox{ если } x \in X\\
x \mapsto x, &\mbox{ иначе}.\\
\end{array}
\right.
$$
и
$$\theta_{X,i}^{-1}= 
\left\lbrace\begin{array}{ll}
x\#i \mapsto x, & \mbox{ если } x \in X\\
x \mapsto x, &\mbox{ иначе}.\\
\end{array}
\right.
$$

Определим $(\varphi)^\pi$ -- логическую предикатную абстракцию формулы $\varphi$.

Определим $SP_{op}(\varphi)$ -- сильнейшее постусловие $\varphi$ и операции $op$.
Для cpa-оператора $assign:$ $SP_{x = exp}(\varphi) = \varphi[x \rightarrow \hat x] \land ( x = exp)$.
Для cpa-оператора $assume:$ $SP_{[cond]}(\varphi) = \varphi \land cond$.
Для остальных cpa-операторов $SP_{op}(\varphi) = \varphi$.

% Требование: $c \tc{op} c' \land (c_l, c_g) = v \models \varphi \implies (c_l', c_g') = v' \models SP_{op}(\varphi)$

Определим анализ предикатов (Predicate Analysis) $\mathbb{P}=(D_{P},$ $\Pi_{P}, \tatarrow_{P},$ $merge_{P}, stop_{P},$ $prec_{P},$ $compatible_{P}$, $\cdot|_p$, $compose_P)$, который отслеживает значение предикатов над переменными программы.

Воспользуемся общим видом анализа с явным видом переходов, описанном в подразделе~\ref{subsect_transitions}.
 
\begin{enumerate}

\item 
Множество абстрактных состояний $E^S_P = \mathscr{P}$, таким образом, состояние является формулой первого порядка.
Верхний элемент решетки является тождественно истинной формулой
$\top^E = true$, а нижний элемент -- тождественно ложной $\bot^E = false$.
Частичный порядок $\sqsubseteq^E \subseteq E \times E$ определяется как $e \sqsubseteq^E e' \Leftrightarrow e \implies e'$.
Объединение элементов $\sqcup^E: E \times E \to E$ определяет ближайший верхний по решетке элемент в соответствии с частичным порядком.

\begin{equation}
\begin{aligned}
& \forall s_1, \dots, s_n \in E^S_P \\
& C_{check}(\{s_1,\dots, s_n\}) = \\
& \exists v: v \models \theta_{X^{local},1}(s_1) \land \dots \land \theta_{X^{local},n}(s_n)
\end{aligned}
\end{equation}

Cpa-оператор $C_{check}$ проверяет, имеют ли частичные состояния совместными, то есть, имеющими общую глобальную часть ($X^{global}$).
Локальные переменные каждого состояния переименовываются, чтобы избежать путаницы с одинаковыми переменными разных потоков.

Для совместных состояний $s_1, \dots, s_n \in E^S_P$ и для каждого решения 
$v \models \theta_{X^{local},1}(s_1) \land \dots \land \theta_{X^{local},n}(s_n)$
можно определить функцию $\hat v_g = v_{\mid X^{global}}$, представляющую общую глобальную часть состояния и функции $\hat v_1=\theta_{X^{local},1}^{-1}(v)_{\mid X^{local}}, \dots, \hat v_n=\theta_{X^{local},n}^{-1}(v)_{\mid X^{local}}$, представляющие локальные части.

Cpa-оператор композиции для состояний

\begin{equation}
\label{predicate_epp_def}
\begin{aligned}
&\forall s_0, \dots, s_n \in E^S_P, t_0, \dots,t_n \in T, t_i \neq t_j:\\
& \epp^S_P
\left(
\begin{pmatrix}
s_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
s_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
s_n \\
t_n 
\end{pmatrix}
\right\}
\right)= \\
& \begin{cases}
& \left\lbrace 
c \in C 
\left| 
\begin{array}{c}
\forall 0 \le i \le n \\
c_{l}(t_i)=\hat v_i, \\
c_g=\hat v_g
\end{array}
\right.
\right\rbrace, \mbox{if } C_{check}(\{s_0,\dots, s_n\})\\
& \emptyset \mbox{, otherwise}
\end{cases}
\end{aligned}
\end{equation}

Абстрактная дуга $q \in E^T_P$ – это действие, которое может быть выражено или формулой, или обычной CFA дугой: $E^T_P = G \cup \mathcal{G}$.
Где $\mathcal{G}=E^S_P$, то есть эффект окружения - это логическая формула, описывающая изменение состояния.
Однако, функция частичного порядка $\sqsubseteq^T_P$ определена совершенно по-другому: $\forall q_1, q_2 \in \mathcal{G}: q_1 \sqsubseteq^T_P q_2 = (\forall \varphi \in E^S_P, q_1 \land \varphi \implies q_2 \land \varphi$).
Дело в том, что тождественный эффект окружения $\varphi \equiv true$, который был бы верхним элементом в прежней решетке, означает, что никаких изменений глобальных переменных не произошло.
Соответственно, верхним элементом решетки абстрактных дуг должен стать элемент, означающий, что изменились значения всех переменных неопределенным образом, то есть, после применения которого результирующая формула будет $\varphi' \equiv true$.
Отсюда такая необходимость изменения функции частичного порядка.

\item Множество точности $\Pi_P = 2^\mathscr{P}$ отвечает за точность абстрактного состояния и содержит в себе множество предикатов.

\item Отношение переходов $e \tat{R}_P e'$, $e = (s, g)$, $e' = (s', \top_P)$. 
Так как анализ предикатов не отслеживает следующие релевантные дуги, он возвращает все возможные. 

Для $g \in G$ существует переход c $g = (\cdot, op, \cdot)$, если $s' = SP_{op}(s)$.

Для $g = \varphi \in \mathscr{P}$, $s' = s[x \rightarrow \hat x] \land \varphi$.
То есть, по сути, применение эффекта окружения к состоянию эквивалентно применению $SP_{op}(s)$ для присваивания при том исключении, что операция $op$ уже задана логической формулой.

\item 
Cpa-оператор объединения merge может иметь несколько модификаций, например,
$merge_{Join}$ объединяет обе части перехода:
\begin{equation}
\label{predicate_merge_join_def}
\begin{aligned}
& \forall e, e' \in E, \pi \in \Pi_P, e =(s,g): \\
& merge_{Join}(e, e', \pi) = 
\begin{cases}
& (s \lor s', g) \text{, if } g = g', g \in G \\
& e' \text{, if } g \in G \land g' \in \mathscr{P} \lor g \in \mathscr{P} \land g' \in G \\
& (s \lor s', g \lor g') \text{, if } g, g' \in \mathscr{P}
\end{cases}
\end{aligned}
\end{equation}

Cpa-оператор $merge_{Eq}$ объединяет только абстрактные дуги при равных (или покрытых) состояниях.

Cpa-оператор $merge_{Sep}$ не объединяет элементы: $merge_{Sep}(e, e', \pi) = e'$.

Требование~\ref{cpa_merge_eq} для всех модификаций очевидно выполнено, так как $e \sqsubseteq e'$  по условиям cpa-оператора $\sqcup_P$ решетки.

\item Cpa-оператор останова проверяет, покрыт ли переход $e$ другим переходом из множества достижимых состояний: $stop_{P}(e, R, \pi) = \exists e'\in R: (e \sqsubseteq e')$.

Проверим, что требование~\ref{cpa_stop_eq} выполнено.
\begin{align*}
&\forall e \in E, R, \widehat{R} \subseteq E, \pi \in \Pi: \\
& e \sqsubseteq e' \implies (eq.~\ref{cpa_conc_eq_2}) \implies \conctm{\widehat{R} \cup R \cup e} \subseteq \conctm{\widehat{R} \cup R \cup e'} \implies  \\
& \implies (eq.~\ref{cpa_conc_eq_0}) \implies \conctm{\widehat{R} \cup e} \subseteq \conctm{\widehat{R} \cup R} 
\end{align*}

\item Функция настройки точности $prec_P$ вычисляет предикатную абстракцию над предикатами в точности $prec_{P}(e, \pi, R) = e^{\pi} = (s^{\pi}, q)$.
Условие~\ref{cpa_prec_eq} выполнено, так как $e \sqsubseteq e^{\pi}$.

\item 
Определим cpa-оператор $compatible_P$.

\begin{equation}
\label{cpa_predicate_compatible}
\begin{aligned}
& \forall e_1, e_2 \in E_P, e = (s, q) \\
& compatible_{P}(e_1, e_2) = \exists v: v \models s_1 \land s_2
\end{aligned}
\end{equation}

\item Cpa-оператор проекции строит логическую формулу по выражению также, как это делается при обычном переходе, но переименовывает все встречающиеся в ней локальные переменные для избежания проблем с несколькими одинаковыми потоками.

\begin{equation}
\begin{aligned}
& \forall e \in E_P, e =(s,q): \\
& e|_p = 
\begin{cases}
&e, \mbox{ if } q \notin G\\
&(\theta_{X^{local},env}(s),\theta_{X^{local},env}(SP_{op}(true))), \mbox{ otherwise}
\end{cases}
\end{aligned}
\end{equation}

\item Cpa-оператор $compose$ является обычным~\ref{default_compatible_def}.

\end{enumerate}

Доказательство того, что определение отношения переходов удовлетворяет условию~\ref{cpa_transfer_composite_req}, приведено в разделе Приложения~\ref{sect_transfer_predicate_proof}. 


\section{Анализ примитивов синхронизации}
\label{sect_lock_analysis}

Определим анализ примитивов синхронизации (Lock Analysis) $\mathbb{S}=((D_{S},$ $\Pi_{S}, \tatarrow_{S},$ $merge_{S}, stop_{S},$ $prec^E_{S},$ $compatible_{S}$, $\cdot|_p$, $compose_S)$, который отслеживает множество захваченных блокировок (переменных синхронизации) для каждого потока. 

\begin{figure}[h]
\begin{minipage}[h]{0.3\textwidth}
\begin{verbatim}
   int g = 0;
   int main {
     lock();
     g = g + 1;
     unlock();
     ...
  }
\end{verbatim}
\caption{Пример исходного кода}
\label{LockCodeExample}
\end{minipage}
\hfill
\begin{minipage}{0.6\textwidth}
    \center{\includegraphics[scale=0.6]{LockCPA-img.pdf}}
    \caption{Пример переходов LockCPA}
    \label{img:LockCPA}
\end{minipage}
\end{figure}

Рисунок~\ref{img:LockCPA} демонстрирует пример переходов анализа примитивов синхронизации.
В абстрактном состоянии накапливается информация о захваченных блокировках. 

Перейдем к формальному описанию LockCPA.
Для этого снова воспользуемся явным видом перехода, описанным в разделе~\ref{subsect_transitions}.
Он состоит из следующих компонент.

\begin{enumerate}

\item Множество абстрактных состояний $E^S_S = 2^S \cup \{\bot^S_S\}$ состоит из множества всех подмножеств всех переменных синхронизации.
При этом $\top^S_S = \emptyset$.
$s \subseteq s'$ $\Rightarrow$ $s \sqsupseteq^S_S s'$ для всех элементов $s, s' \subseteq S$ 
(откуда следует $\bot^E \sqcup^E s = s$, $\top^E \sqcup s=\top^E$, $ s\sqcup^E s' = s \cap s'$ для всех элементов $s,s'\subseteq S$, $s\neq s'$).

В данном анализе cpa-оператор является тривиальным, так как потоки могут находиться в любых точках программы независимо друг от друга:
$\forall s_0, \dots, s_n \in E^S_S: C_{Check}(\{s_0, \dots, s_n\}) = \forall 0 \le i,j \le n: (s_i \neq \bot^S_S \land s_j \neq \bot^S_S \land s_i \cap s_j = \emptyset$.

\begin{align*}
&\forall s_1, \dots, s_n \in E^S_S:\\
&\epp^S_{S}
\left(
\begin{pmatrix}
s_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
s_1' \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
s_n' \\
t_n 
\end{pmatrix}
\right\}
\right) = \\ 
& = \begin{cases}
& \{ c \in C \mid \hat s \in s_i \implies c_s(\hat s) = t_i \}  \mbox{, если } C_{Check}(\{s_0, \dots, s_n\}) \\
& \emptyset \mbox{, иначе}
\end{cases}
\end{align*}

Такое определение cpa-оператора $\epp^S_{S}$ очевидно удовлетворяет условиям~\ref{cpa_tm_epp_split_req_1},~\ref{cpa_tm_epp_split_req_2}, так как уменьшение количества переменных блокировок в состоянии только ослабляют условия, а значит, позволяют получить большее количество конкретных состояний.

Множество абстрактных дуг содержит только тождественную дугу, которая не меняет абстрактное состояние, и верхний и нижний элементы решетки: $\mathcal{G} = \{\bot^T_S, \varepsilon, \top^T_S\}$.
Cpa-оператор конкретизации для дуг является тривиальным: $\econc{\bot^T_S} = \emptyset$, $\econc{\varepsilon} = \econc{\top^T_S} = G$.
Cостояния этого анализа {\em инвариантны к окружению}, то есть ни один поток не может изменить точку в программе, на которой находится другой поток.

\item Множество точности содержит только один элемент $\Pi_S = \{\{\emptyset\}\}$, так как не подразумевается применение абстракции.

\item Отношение переходов $\tatarrow_S$ содержит переход $e \tat{R}_S e'$, $e = (s,q)$, $e' = (s', \top^T_S)$, если


\begin{itemize}
 \item $q \in G$, $q=(\cdot,op,\cdot')$ и 
\begin{itemize}
\item $op=acquire(\hat s)$ и $\hat s \notin s \land s' = s \cup \{\hat s\}$,
\item $op=release(\hat s)$ и $s' = s \setminus \{\hat s\}$,
\item $op=tc_{child}(l_\nu)$ и $s' = \emptyset$. 
\item $op \neq acquire$ и $op \neq release$ и $op \neq tc_{child}$ и $s' = s$.
\end{itemize}
 \item $q = \varepsilon$ и $s' = s$.
\end{itemize}

\item Cpa-оператор слияния не объединяет абстрактные состояния: $merge_S(e, e', \pi) = e'$. Условие~\ref{cpa_merge_eq} очевидно выполнено.

\item Cpa-оператор останова проверяет, существует ли состояние, которое содержит меньше захваченных блокировок: $stop_S(e, R, \pi) = (\exists e' \in R \land e \sqsubseteq e')$.
Проверим, что требование~\ref{cpa_stop_eq} выполнено.
\begin{proof}
\begin{align*}
&\forall e \in E, R, \widehat{R} \subseteq E, \pi \in \Pi: \\
& e \sqsubseteq e' \implies (eq.~\ref{cpa_conc_eq_2}) \implies \conctm{\widehat{R} \cup R \cup e} \subseteq \conctm{\widehat{R} \cup R \cup e'} \implies \\
& \implies (eq.~\ref{cpa_conc_eq_0}) \implies \conctm{\widehat{R} \cup e} \subseteq \conctm{\widehat{R} \cup R} 
\end{align*}
\end{proof}

\item Точность анализа никогда не изменяется: $prec_S(e, \pi, R) = (e, \pi)$.

\item $\forall e_1, e_2 \in E^S_S: compatible_S(e_1,e_2) = (e_1 \cap e_2 = \emptyset)$

\item Cpa-оператор $compose$ является обычным~\ref{default_compatible_def}.

\item Переходы являются {\em инвариантными к окружению}, то есть ни один поток не может изменить положение другого потока.
Это означает, что проекцией является тождественный переход:
$(s, q)|_p = (s, \varepsilon)$.
\end{enumerate}

Доказательство того, что определение отношения переходов удовлетворяет условию~\ref{cpa_transfer_composite_req}, приведено в разделе Приложения~\ref{sect_transfer_lock_proof}. 


\section{Анализ явных значений}
\label{sect_value_analysis}

Определим анализ явных значений (Value Analysis) $\mathbb{V}=((D_{V},$ $\Pi_{V}, \tatarrow_{V},$ $merge_{V}, stop_{V},$ $prec_{V},$ $compatible_{V}$, $\cdot|_p$, $compose_V)$, который отслеживает явные значения переменных.
В отличие от анализа предикатов ValueCPA хранит только значения переменных, а значит, не может отлеживать более сложные зависимости между переменными. 

\begin{figure}[h]
\begin{minipage}[h]{0.3\textwidth}
\begin{verbatim}
  1: int main {
  2:   int y = 3;
  3:   int x = y + 1;
  4:   if (x > 0) {
  5:    ...
  6:  }
  }
\end{verbatim}
\caption{Пример исходного кода}
\label{ValueCodeExample}
\end{minipage}
\hfill
\begin{minipage}{0.65\textwidth}
    \center{\includegraphics[scale=0.7]{ValueCPA-img.pdf}}
    \caption{Пример переходов ValueCPA}
    \label{img:ValueCPA}
\end{minipage}
\end{figure}

Рисунок~\ref{img:ValueCPA} демонстрирует пример переходов анализа явных значений.
В абстрактном состоянии содержится отображение из переменных в их значения. 

Перейдем к формальному описанию ValueCPA.
Для этого снова воспользуемся явным видом перехода, описанным в разделе~\ref{subsect_transitions}.
Он состоит из следующих компонент.

\begin{enumerate}

\item Абстрактное состояние этого анализа является отображением из имен переменных в их значение:
$\forall s \in E^S_V, s: X \to \mathcal{Z}$, где $\mathcal{Z} = \mathbb{Z} \cup \{\bot_Z, \top_Z\}$.
Таким образом, множество абстрактных состояний $E^S_V$ является плоской решеткой над целыми числами.
Верхний элемент решетки $\top^S_V = \{v \mid \forall x \in X: v(x) = \top_Z\}$ является отображением, в котором каждая переменная имеет любое значение.
А нижний элемент решетки $\bot^S_V = \{v \mid \exists x \in X: v(x) = \bot_Z\}$ является отображением, в котором хотя бы одна переменная не может иметь никакого явного значения.
Такое состояние является недостижимым при реальном выполнении программы. Порядок является тривиальным: любые два невырожденных состояния (неравные $\top^S_V$ или $\bot^S_V$) являются несравнимыми.

Cpa-оператор $C_{Check}$ проверяет, существует ли общее отображение глобальных переменных:
$\forall s_0, \dots, s_n \in E^S_V: C_{Check}(\{s_0, \dots, s_n\}) = \forall x \in X^g, \exists z \in \mathcal{Z}: \forall 0 \le i \le n: z = s_i(x) \lor s_i(x) = \top_Z$.
Обозначим такое общее отображение через $\hat v_g$.

\begin{align*}
&\forall s_1, \dots, s_n \in E^S_V:\\
&\epp^S_{S}
\left(
\begin{pmatrix}
s_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
s_1' \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
s_n' \\
t_n 
\end{pmatrix}
\right\}
\right) = \\ 
& = \begin{cases}
& \{ c \in C \mid \forall x \in X^g: \hat v_g(x) \neq \top_Z \implies c_g(x) = v_g(x) \} \\
& \hspace{1cm}  \mbox{, если } C_{Check}(\{s_0, \dots, s_n\}) \\
& \emptyset \mbox{, иначе}
\end{cases}
\end{align*}

Такое определение cpa-оператора $\epp^S_{S}$ очевидно удовлетворяет условиям~\ref{cpa_tm_epp_split_req_1},~\ref{cpa_tm_epp_split_req_2}, так как большее состояние ($\sqsubseteq^S_V$) означает только $\top^S_V$, что, очевидно, только расширяет множество конкретных состояний.

Множество абстрактных дуг содержит множество обычных CFA дуг и переходы в окружении, которые определяются изменением глобальных переменных:
$E^T_V = 2^{X \to \mathcal{Z}} \cup G$.
Тождественный переход $\varepsilon = \emptyset$ является пустым отображением, при котором ни одна переменная не меняет своего значения.
Cpa-оператор конкретизации для дуг $\econc{\cdot}$ сопоставляет каждому отображению множество дуг, которое может иметь такое отображение.
Например, $\econc{x \to a} = \{g \mid g = (\cdot, assign(x, a), \cdot)\}$.

\item Точность анализа явных значений определяется отслеживаемыми переменными, таким образом множество точности содержит подмножества из всех переменных программы:  $\Pi_V = 2^X$.

\item Отношение переходов $\tatarrow_V$ содержит переход $e \tat{R}_V e'$, с $e=(s,q)$, $e' =(s', \top^T_V)$, если 
\begin{itemize}
\item $q \in G, q=(\cdot,assume(expr),\cdot')$ 
\begin{align*}
&\forall x \in X: s'(x) = 
\begin{cases}
& \bot_Z \mbox{, если } \nexists a \in \mathbb{Z}. (x \rightarrow a) : (expr\neq 0)_{/s} \\
& a \mbox{, если } \exists !a \in \mathbb{Z}. (x \rightarrow a) : \\
& \hspace{2cm} (expr\neq 0)_{/s} \lor s(x) = c \\
& \top_Z{, иначе }
\end{cases}
\end{align*}
Здесь $(expr)_{/s}$ означает интерпретацию выражения $expr$ над переменными из $X$ для абстрактного присваивания $s$.
А выражение $(x \rightarrow a) : (expr\neq 0)_{/s}$ означает, что значение $a$ у переменной $x$ удовлетворяет интерпретации.
\item $q \in G, q=(\cdot,assign(w, expr),\cdot')$ 
\begin{align*}
&\forall x \in X: s'(x) = 
\begin{cases}
& expr_{/s} \mbox{, если } x = w \\
& s(x){, иначе }
\end{cases}
\end{align*}
\item $q \in G$ в остальных случаях состояние не меняется: $s' = s$. 
\item $q: X \to \mathcal{Z}$, что означает, что мы имеем переход, который меняет определенные переменные.
В этом случае, следующее состояние
\begin{align*}
&\forall x \in X: s'(x) = 
\begin{cases}
& q(x) \mbox{, если } x \in dom(q) \\
& s(x){, иначе }
\end{cases}
\end{align*}
\end{itemize}

\item Cpa-оператор слияния не объединяет абстрактные элементы: $merge_V(e, e', \pi) = e'$. Условие~\ref{cpa_merge_eq} очевидно выполнено.

\item Cpa-оператор останова рассматривает уникальные состояния: $stop_S(e, R, \pi) = (\exists e' \in R \land e \sqsubseteq e')$.
Проверим, что требование~\ref{cpa_stop_eq} выполнено.
\begin{proof}
\begin{align*}
&\forall e \in E, R, \widehat{R} \subseteq E, \pi \in \Pi: \\
& e \sqsubseteq e' \implies (eq.~\ref{cpa_conc_eq_2}) \implies \conctm{\widehat{R} \cup R \cup e} \subseteq \conctm{\widehat{R} \cup R \cup e'} \implies \\
& \implies (eq.~\ref{cpa_conc_eq_0}) \implies \conctm{\widehat{R} \cup e} \subseteq \conctm{\widehat{R} \cup R} 
\end{align*}
\end{proof}

\item Функция настройки точности вычисляет новое абстрактное состояние и точность, ограничивая присваивания только теми переменными, которые содержатся в точности: $prec_V(e, \pi, R) = (e_{\pi}, \pi)$.

\item $\forall e_1, e_2 \in E_V: compatible_V(e_1,e_2) = C_{check}(\{s_1, s_2\})$.

\item Cpa-оператор $compose$ является обычным~\ref{default_compatible_def}.

\item Переход в окружении может затрагивать только глобальные переменные: $\forall e \in E_V, e=(s,q):e|_p=(s^{global},q^{global})$.
 Здесь отображение $s^{global}$ означает только ту часть, которая относится к глобальным переменным.
\end{enumerate}

Доказательство того, что определение отношения переходов удовлетворяет условию~\ref{cpa_transfer_composite_req}, приведено в разделе Приложения~\ref{sect_transfer_value_proof}. 

\section{Метод поиска состояния гонки}
\label{sect_race_theory}

Метод поиска состояния гонки заключается в построении множества достижимых абстрактных переходов с помощью алгоритма CPA~\ref{cpata_algorithm_ps}, а затем в поиске пары абстрактных переходов, начальные состояния которых являются совместными, а сами переходы производят доступ к разделяемой области памяти, при этом хотя бы один из доступов является записью.

Построение множества достижимых состояний производится с помощью комбинации описаных ранее CPA.
Возможны различные конфигурации CPA, в зависимости от поставленной задачи, например, такая: анализ точек программы $\mathcal{L}$, анализ потоков $\mathbb{T}$, анализ примитивов синхронизации $\mathbb{S}$ и анализ предикатов $\mathbb{P}$. Все эти анализы объединяются с помощью композитного анализа $\mathbb{C}$.
Кроме различного множества используемых CPA возможно более точная настройка каждого CPA в отдельности, например, изменением варианта cpa-оператора $merge$.

Тем не менее, было показано, что cpa-операторы каждого из этих видов анализа удовлетворяют условиям~\ref{cpa_transfer_eq},~\ref{cpa_merge_eq},~\ref{cpa_stop_eq},~\ref{cpa_prec_eq}, а значит, позволяют утверждать по теореме~\ref{thrm_soundness}, что множество вычисленных абстрактных состояний аппроксимирует сверху множество конкретных состояний программы.
Таким образом, если в числе абстрактных состояний программы присутствует ошибочное, значит, программа не соответствует поставленной спецификации.

Покажем, что для программы, содержащей состояний гонки в смысле определения~\ref{raceDef}, будет найдено состояние гонки на абстрактных состояниях.
Пусть у нас есть множество достижимых состояний $R: \exists c, c_1, c_2 \in \conc{R} \subseteq C, g_1, g_2 \in G, \widehat{t}, \overline{t} \in T, \widehat{t} \neq \overline{t}: c \tc{g_1, \widehat{t}} c_1, c \tc{g_2, \overline{t}} c_2$, то есть присустствует состояние гонки.
По теореме~\ref{thrm_soundness} это означает, что 
\begin{align*}
& \exists e_0, e_1, \dots, e_n, \tilde{e}_0, \tilde{e}_1, \dots, \tilde{e}_n \in R, \\
& t_0, \dots, t_n, \tilde{t_0}, \dots, \tilde{t}_n \in T, \\
& \tau_1 \in \epp
\left(
\begin{pmatrix}
e_0 \\
t_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
e_1 \\
t_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
e_n \\
t_n 
\end{pmatrix}
\right\}
\right), \\
& \tau_1 \in \epp
\left(
\begin{pmatrix}
\tilde{e}_0 \\
\tilde{t}_0 
\end{pmatrix},
\left\{
\begin{pmatrix}
\tilde{e}_1 \\
\tilde{t}_1 
\end{pmatrix},
\dots ,
\begin{pmatrix}
\tilde{e}_n \\
\tilde{t}_n 
\end{pmatrix}
\right\}
\right), \\
\end{align*}

По требованию~\ref{cpa_transfer_inner_req} переход $e_0$ должен быть применим ($apply$) ко всем переходам $\tilde{e}_i$, а значит и к $\tilde{e}_0$.
Таким образом, получаем, что переходы $e_0$ и $\tilde{e}_0$ должны быть совместны.
При этом требования на абстракные операции $q_1, q_2$ должны быть теми же, что и в определении состояния гонки~\ref{raceDef}: доступ к одной области памяти, и хотя бы одна операция записи.
Итак, можно сформулировать определение состояния гонки на абстрактных состояниях.

\begin{defn}
\label{raceDef_abstract}
Программа, для которой получено множество достижимых абстрактных состояний $R$, содержит \textbf{состояние гонки}, если $\exists e_1, e_2 \in R$, $e_i=(s_i,q_i)$, $q_1, q_2 \in G$, $compatible(e_1, e_2)$ и операции $g_1, g_2$ выполняются над одной и той же глобальной переменной $x \in X^{global}$ и хотя бы одна операция является присваиванием (то есть $assign(x, expr)$).
\end{defn}

Определение~\ref{raceDef_abstract} является ключевым в данном методе. 
Именно оно определяет, какие именно состояния будут трактоваться, как ошибочные.
Особенное внимание следует обратить на использование оператора compatible, который изначально появился при описании алгоритма построения окружения.
Этот оператор позволяет накладывать дополнительные ограничения на рассматриваемые пары абстрактных переходов, что повышает точность анализа.

Итак, метод поиска состояний гонки состоит из двух основных частей.

\begin{itemize}
\item Построение множества достижимых состояний с использованием подхода с раздельным анализом потоков.
\item Поиск таких пар абстрактных переходов, которые удовлетворяют определению~\ref{raceDef_abstract}.
\end{itemize}
