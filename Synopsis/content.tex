
\section*{Общая характеристика работы}

\newcommand{\actuality}{\underline{\textbf{\actualityTXT}}}
\newcommand{\progress}{\underline{\textbf{\progressTXT}}}
\newcommand{\aim}{{\textbf\aimTXT}}
\newcommand{\aimandtasks}{\underline{{\textbf\aimandtasksTXT}}}
\newcommand{\tasks}{\textbf{\tasksTXT}}
\newcommand{\novelty}{\underline{\textbf{\noveltyTXT}}}
\newcommand{\influence}{\underline{\textbf{\influenceTXT}}}
\newcommand{\methods}{\underline{\textbf{\methodsTXT}}}
\newcommand{\defpositions}{\underline{\textbf{\defpositionsTXT}}}
\newcommand{\reliability}{\underline{\textbf{\reliabilityTXT}}}
\newcommand{\probation}{\underline{\textbf{\probationTXT}}}
\newcommand{\contribution}{\underline{\textbf{\contributionTXT}}}
\newcommand{\publications}{\underline{\textbf{\publicationsTXT}}}

\input{common/characteristic} % Характеристика работы по структуре во введении и в автореферате не отличается (ГОСТ Р 7.0.11, пункты 5.3.1 и 9.2.1), потому её загружаем из одного и того же внешнего файла, предварительно задав форму выделения некоторым параметрам

\underline{\textbf{Объем и структура работы.}} Диссертация состоит из~введения, четырех глав, заключения и~двух приложений. Полный объем диссертации 220~страниц текста с~23~рисунками и~28~таблицами. Список литературы содержит 98~наименований.

%\newpage
\section*{Содержание работы}
Во \underline{\textbf{введении}} обосновывается актуальность
исследований, проводимых в~рамках данной диссертационной работы,
формулируется цель, ставятся задачи работы, излагается научная новизна
и практическая значимость представляемой работы.
В~первой главе приводится обзор научной литературы по изучаемой проблеме, во второй главе описывается теоретические основы метода, доказывается его корректность в некоторых предположениях.
В третьей главе описывается схема реализации и архитектура разработанного инструмента.
В четвертой главе представлены результаты апробации на частных примерах: как на множестве тестовых примеров, так и на исходном коде реальных операционных систем.

\underline{\textbf{Первая глава}} посвящена обзору существующих методов поиска ошибок использования различных примитивов синхронизации в многопоточном программном обеспечении.
В разделе 1.1 кратко определяются основные методы поиска ошибок: экспертиза кода, статические методы, динамические методы и формальные методы.
Далее приводятся основные критерии инструментов верификации, которые являются важными для решения задачи проверки корректной синхронизации системного программного обеспечения: точность, масштабируемость и поддержка сложных конструкций языка Си.

В разделе 1.2 определяются общие термины, которые будут использованы при проведении обзора: многопоточная программа, доступ к данным, алгоритмы Lockset и Happens-Before для поиска состояний гонки и другие.

В разделе 1.3 рассматриваются методы динамического анализа.
% Другой характерной особенностью данного метода является высокий процент истинных предупреждений.
%Некоторые методы динамического позволяют гарантировать, что обнаруженное предупреждение является реальной ошибкой, а не ложной. 
%Однако, такая возможность доступна, если поиск ошибок производится только на тех путях, которые были получены при конкретном выполнении программы.
%Перебрать все варианты выполнения даже небольшой программы невозможно за разумное время, поэтому применяются различные механизмы анализа множества путей, похожих на те, которые возникают при реальном выполнении.
%Такой подход значительно ускоряет процесс анализа, но приводит к получению ложных предупреждений. 
%Тем не менее, процент ложных предупреждений у инструментов, реализующих методы динамического анализа, обычно значительно ниже, чем у тех, что основаны на других подходах.
В разделе рассматриваются основные подклассы методов динамического анализа: методы на основе векторных часов, статико-динамические методы, узкоспециализированные методы.
Методы динамического анализа на основе векторных часов применяются для поиска ошибок синхронизации во время работы программы, поэтому одна из основных характеристик таких методов -- это замедление целевой программы. 
Статико-динамические методы используют предварительный анализ кода для получения первичного множество предупреждений, которое необходимо проверить при реальном выполнении программы.
Узкоспециализированные методы обычно нацеливаются либо на ошибки специального типа, например, ad-hoc синхронизации, либо на программное обеспечение специального вида, например, MySQL сервер.
Основной вывод заключается в том, что методы динамического анализа не являются полными, т.е. достаточными для проверки для проверки системного программного обеспечения.

В разделе 1.4 рассматриваются методы статического анализа.
Основной задачей таких методов является нахождение ошибок при как можно меньшем числе ложных предупреждений и наименьших затратах ресурсов. 
Многие из методов статического анализа являются корректными, то есть способны не пропускать ошибки, но в этом случае процент ложных срабатываний будет слишком большой.
Большое количество ложных срабатываний сильно затрудняет ручной анализ предупреждений, поэтому зачастую применяются различные фильтры, которые сокращают число ложных сообщений об ошибках.
Однако, такие фильтры являются лишь неточными эвристиками, которые снижают корректность метода в целом и способны привести к пропуску реальных ошибок.
%Эти методы похожи на те, которые были рассмотрены в предыдущем разделе, однако, в отличие от методов проверки моделей, методы статического анализа не ставят целью возможность доказательства отсутствия ошибок в программе.
Таким образом, методы статического анализа также не являются полными, т.е. достаточными для проверки системного программного обеспечения.

В разделе 1.5 рассматриваются различные методы статической верификации (англ. software model checking).
Такие методы основаны на том, что автоматически строится некоторая формальная модель программы, а затем эта модель проверяется на соответствие заданным свойствам.
Такие методы являются достаточно точными при условии, что модель достаточно хорошо соответствует исходной программе.
Одним из важных минусов таких методов являются высокие требования к ресурсам.
Другим минусом статической верификации является то, что на реальном программном обеспечении достаточно сложно достигнуть высокого уровня соответствия модели и исходной программы, что приводит к большому количеству ложных срабатываний.
К плюсам можно отнести возможность формального доказательства, что в программе отсутствуют дефекты определенного типа, опять же, при условии адекватности построенной модели.
%В разделе рассматриваются методы статической верификации на основе чередований, на основе трансляции, на основе раздельного рассмотрения потоков и другие.

В разделе 1.6 подводятся основные итоги обзора и делаются выводы.
Результаты обзора позволяют заключить, что основные усилия сейчас сосредаточены на анализе пользовательских приложений.
%,системное программное обеспечение является слишком объемным и слишком сложным для применения общецелевых методов.
Применение методов динамического анализа к системному программному обеспечению осложняется тем, что требуется трудоемкая настройка тестового окружения.
%, в том числе аппаратуры.
Кроме того, методы динамического анализа не способны обеспечить гарантию отсутствия ошибок.
Методы статического анализа успешно применяются к любым объемам кода любой сложности. 
В случае применения таких методов к большому объему сложного кода будет получено огромное количество предупреждений.
Анализ этих предупреждений вручную может потребовать большого количества времени.
Методы статической верификации способны дать гарантию отсутствия дефектов определенного типа, в некоторых разумных, заранее известных предположениях.
Однако, такие методы не способны в настоящее время успешно применяться к большим объемам исходного кода.

Таким образом, можно заключить, что в настоящее время отсутствуют такие методы анализа больших объемов системного кода, в том числе, операционных систем, которые могут обеспечить высокий уровень надежности.
%Данная работа посвящена описанию разработанного метода поиска состояний гонки, который может применяться к реальным программным системам.

\underline{\textbf{Вторая глава}} посвящена описанию разработанного метода поиска состояний гонки.
Основная идея метода заключается в том, что каждый поток в программе анализируется независимо от остальных.
В этом случае удастся избежать комбинаторного взрыва состояний, который бы неизбежно присутствовал, если бы анализ проводился с учетом всех взаимодействий между потоками.
Для того, чтобы обеспечить достаточно высокую точность метода, поток анализируется в некотором окружении, которое формируется с учетом других потоков программы. 
Уровень точности окружения, который требуется для анализа, может гибко настраиваться.

Метод с раздельным анализом потоков может внутри себя использовать уже существующие техники и подходы, например, такие как CEGAR.
В этом случае необходимо предложить обобщенный алгоритм анализа программ, частным случаем которого уже будут как классические подходы к анализу последовательных программ, так и различные подходы к анализу многопоточных программ, в частности, предложенный подход с раздельным анализом потоков. 

Для того чтобы доказать корректность предложенного подхода, необходимо определить формальную семантику программы, то есть ее математическую модель.
С помощью предложенного подхода строится некоторая абстракция этой математической модели. 
Адекватность такой абстракции определяется тем, что каждое из возможных поведений модели должен присутствовать и в абстракции.
Таким образом, ошибка не может быть пропущена.
Именно в этом смысле далее используется термин корректность анализа (англ. soundness).

В разделе 2.1 описана семантика многопоточных программ. 
Формальная модель программы определяется, как множество конкретных состояний программы, которые описываются значениями переменных каждого из потоков, а также глобальных переменных, статусом примитивов синхронизации и информацией об активных потоках.
Далее описывается семантика всех поддерживаемых операторов программы, то есть задаются правила преобразования конкретных состояний операторами программы.
В число поддерживаемых операторов входят операторы условия (англ. assumption), присваивания (англ. assignment),
кроме того, специальные операторы работы с примитивами синхронизации: захват блокировки и ее освобождение, а также создание потока (thread\_create).
% и ожидания завершения потока (thread\_join).
В заключении даны определения ошибки в программе, в частности, определение состояния гонки.

В разделе 2.2 описан адаптивный статический анализ (англ. Configurable Program Analysis, CPA), который является формальной математической моделью некоторого статического анализа программы.
CPA определяется доменом абстрактных переходов и операторами над этими абстрактными переходами: оператором перехода $transfer$, оператором объединения $merge$ и оператором останова $stop$.
Каждый из этих операторов должен удовлетворять некоторым условиям для обеспечения корректности.
Одним из важных отличий данного определения от классического варианта теории является использование абстрактных переходов вместо абстрактных состояний.
Это необходимо для возможности построения абстракции не только над конкретными состояниями, но и над конкретными дугами, то есть операциями программы.
Еще одним важным отличием данного определения является ослабление условия на оператор $transfer$, что позволяет определять более сложные CPA.

В разделе 2.3 описан обобщенный алгоритм вычисления множества достижимых переходов (алгоритм~\ref{cpata_algorithm_ps}).

\begin{algorithm}
% Plain Algorithm
 \KwData{
 адаптивный статический анализ $\mathbb{D}=(D$, $\Pi$, $\tatarrow$, $merge$, $stop$, $prec$),
 {начальный абстрактный переход $e_0$ с точностью $\pi_0 \in \Pi$},
 {множество $reached$ элементов из $E \times \Pi$},
 {множество $waitlist$ элементов из $2^{E \times \Pi}$}
 }
\KwResult{множество достижимых состояний $reached$}
 $waitlist := \{(e_0, \pi_0)\}$\;
 $reached := \{(e_0, \pi_0)\}$\;

 \While{$waitlist \neq \emptyset$}{
  pop $(e, \pi)$ from $waitlist$\;  
  \For{$e'$ : $(e, \pi) {\color{blue} \tat{reached}} e'$ }{
   $(\widehat{e}, \widehat{\pi})=prec(e',\pi,reached)$\;
   \For{$(e'', \pi'') \in reached$}{
    $e_{new} = merge(\widehat{e}, e'', \widehat{\pi})$\;
    \If{$e_{new} \neq e''$}{
     $waitlist := waitlist \setminus \{(e'',\pi'')\} \cup \{(e_{new},\pi'')\}$\;
     $reached := reached \setminus \{(e'',\pi'')\} \cup \{(e_{new},\pi'')\}$\;
    }
   }
   \If{$!stop(\widehat{e}, reached, \widehat{\pi})$}{
    $waitlist := waitlist \cup \{(\widehat{e}, \widehat{\pi})\}$\;
    $reached := reached \cup \{(\widehat{e}, \widehat{\pi})\}$\;
   }
  }
 }%repeat

% Thin about the caption
 \caption{Алгоритм $CPA(\mathbb{D}, e_0, \pi_0)$}
 \label{cpata_algorithm_ps}
\end{algorithm} 

Одним из важных особенностей предложенного обобщенного алгоритма является то, что его абстрактные переходы являются частичными, то есть множество конкретных переходов программы, соответствующее некоторому частичному абстрактному переходу, может зависить не только от этого перехода, но и от других частичных переходов. 

Сам алгоритм остается практически неизменным по сравнению с классическим вариантом, за исключением небольшого изменения оператора $transfer$, что является необходимым для обеспечения возможности рассмотрения переходов из любого множества абстрактных состояний. 
Основное отличие возникает при доказательстве корректности этого алгоритма, то есть, утверждения о том, что построенное множество абстрактных переходов аппроксимирует сверху множество конкретных переходов.
Доказательство этой теоремы приведено в приложении.

В разделе 2.4 кратко описана схема использования и конфигурации CPA. 
Настройка, или конфигурация, CPA позволяет добиться требуемого баланса между скоростью и точностью анализа. 
Комбинация различных CPA между собой позволяет нивелировать различные недостаки одних CPA с помощью других, что позволяет повысить точность анализа.
 
В разделе 2.5 представлен алгоритм, реализующий функциональность подхода с раздельным анализом потоков, в том числе, построение окружения.
Этот алгоритм не только рассматривает обычные переходы (т.н. \textit{переходы в потоке}), но и строит специальные \textit{переходы в окружении}, которые представляют собой влияние потоков друг на друга.
Для описания этого алгоритма используется набор операторов: оператор проекции $\cdot|_p$, оператор составления перехода $compose$ и оператор проверки совместности $compatible$.

Переходы в окружении моделируют изменение состояния отдельного потока в результате действий другого потока.
Для построения окружения используется оператор проекции, который представляет как выглядит тот или иной переход для другого потока.
Таким образом, если переход не модифицирует разделяемые данные, его проекцией будет тождественный переход, означающий, что он не может повлиять на состояния других потоков.
Каждая полученная проекция должна быть применена к каждому переходу потока, если это возможно.
Возможность применения задает оператор $compatible$, который, по сути, проверяет могут ли проекция и переход в потоке выполняться параллельно. 
Обычно, эта проверка означает то, что два частичных состояния могут соответствовать одному конкретному состоянию.
В частности, отсюда следует, что все значения разделяемых данных должны совпадать.

Кроме того, в разделе рассмотрен предельный случай CPA, который является инвариантным к переходам в окружении.
Такое свойство позволяет значительно повысить скорость анализа за счет применения более эффективных оптимизаций.

В разделе 2.6 показано, как классический вариант подхода с раздельным рассмотрением потоков без абстракции может быть выражен с использованием предложенной теории. 
Это демонстрирует ее выразительность.

В разделе 2.7 представлено формальное определение CompositeCPA, который обеспечивает композицию различных CPA между собой.
Его домен представляет собой декартово произведение доменов внутренних CPA, а все операторы используют параллельную композицию соответствующих операторов внутренних CPA.
Кроме того, CompositeCPA может усиливать переходы одних CPA за счет информации из других.
Для этого служит специальный оператор $strengthen$.
В данном случае, если некоторый CPA не может определить единственную CFA дугу для следующего перехода, данный CPA может подсказать ему, используя информацию о том, по какой дуге будут переходить следующие CPA.
Такая реализация оператора $strengthen$ является достаточно тривиальной и в дальнейшем может быть усилена.

Разделы 2.8, 2.9, 2.10 посвящены описанию различных вариантов ThreadCPA, который отслеживает множество активных потоков.
Простой его вариант может лишь отличить один поток от другого, но не может определить, может ли он выполняться параллельно, что приводит к снижению точности анализа.
Вариант с использованием эффектов окружения позволяет учитывать зависимости по созданию потоков, а значит, позволяет вычислять совместные переходы более точно, однако не является инвариантным к переходам в окружении.
Наконец, расширенный вариант ThreadCPA позволяет обеспечить необходимую точность анализа при сохранении инвариантности к переходам в окружении.

Раздел 2.11 представляет формальную модель LocationCPA, который отвечает за синтаксическую достижимость точек программы.
Данный CPA обеспечивает связь с исходным кодом программы, а также за определение следующих переходов, которые задаются CFA дугами.

Раздел 2.12 посвящен описанию PredicateCPA, который реализует анализ предикатов в случае подхода с раздельным рассмотрением потоков.
Кроме ожидаемых изменений, связанных с дополнительными операторами, и поддержки переходов в окружении, было необходимо обеспечить возможность анализа нескольких потоков, исполняющих одну функцию. 
Это значит, что при переходах в окружении необходимо переименовывать все встречающиеся локальные переменные для избежания коллизии имен.

Раздел 2.13 представляет описание LockCPA, который отслеживает множество испльзуемых примитивов синхронизации.
Данный CPA является инвариантным к переходам в окружении, и его проекции служат лишь для повышения точности оператора $compatible$, так как два перехода не могут выполняться параллельно друг с другом, если был захвачен одна и та же блокировка.

Раздел 2.14 описывает анализ явных значений ValueCPA, который может отслеживать лишь присваивания явных значений в переменные.
%Он является простым анализом по сравнению с анализом предикатов.

В разделе 2.15 представлен основной метод поиска состояний гонки. 
Он основан на алгоритме Lockset, который определяет состояние гонки, как ситуацию, при которой происходит параллельный доступ к разделяемой памяти с непересекающимся множеством блокировок.
Предложенный метод использует оператор $compatible$ и определяет состояние гонки, как пару \textit{совместных} переходов, которые производят параллельный доступ к разделяемой памяти.
Такой метод сводится к алгоритму Lockset при использовании только LockCPA, однако при анализе реальных программ обычно применяются несколько различных CPA совместно, что позволяет повысить точность определения состояний гонки по сравнению с классическим алгоритмом Lockset.

\underline{\textbf{Третья глава}} посвящена описанию реализации разработанного метода поиска состояний гонки.
Далее будем называть инструмент, реализующий предложенный метод, CPALockator.
В этой же главе представлены решения, которые используются для эффективного анализа программного обеспечения.

В разделе 3.1 представлена общее устройство инфраструктуры CPAchecker: используемый парсер, набор различных алгоритмов и CPA, а также автоматный способ задания ошибки.

В разделе 3.2 описана конфигурация и типовой набор CPA, которые включаются в инструмент CPALockator.
Обычно используются следующие CPA: ThreadModularCPA, ARGCPA, CompositeCPA, LocationCPA, CallstackCPA, LockCPA, ThreadCPA, PredicateCPA.
Однако, такая конфигурация не является единственно возможной, и, в зависимости от целевой задачи, возможно исключение или добавление других CPA.

Раздел 3.3 представляет основные оптимизации, сделанные при реализации ThreadModularCPA. 
Основная оптимизация заключается в переходе от операций над переходами в окружении к операциям над проекциями, которых значительно меньше.
А уже после операций $merge$ и $stop$ над проекциями вычисляются переходы в окружении.

Раздел 3.4 описывает одну из важных оптимизаций BAMCPA, которая основана на кэшировании результатов проведенного анализа некоторого абстрактного блока.
Такая оптимизация существенно позволяет ускорить анализ программы, однако в данный момент она не позволяет использовать CPA, которые не являются инвариантными к переходам в окружении.
Данное ограничение является техническим, и в дальнейшем возможна реализация данной оптимизации в общем варианте.

Раздел 3.5 описывает служебный ARG CPA, который обеспечивает построение абстрактного графа достижимости (англ. Abstract Reachability Graph, ARG).
Абстрактные переходы данного CPA содержат в себе связи, соответсвующие операторам.
Например, связи parent-child означает, что дочерний переход был получен из родительского с помощью оператора $transfer$.

Раздел 3.6 представляет основные отличия реализации LockCPA от формально описанной модели. 
Так как в реальных программах блокировки часто используются по указателю, то одним из основных отличий реализации от теории является поддержка возможности работы с указателями.
Использование анализа алиасов является неоправданным для сложного программного обеспечения, поэтому делается предположение, что работа с блокировками ведется одинаковым образом, и если одна блокировка была захвачена по одному указателю, то она будет освобождаться с использованием этого же указателя.
Еще одной возможностью стала поддержка расширенного множества операций над блокировками, в том числе рекурсивный захват.
Также в этом разделе описаны особенности реализации, связанные с оптимизацией BAM.

В разделе 3.7 описаны основные особенности реализации LockationCPA, которые заключаются, в основном, в представлении различных служебных дуг, необходимость в которых появилась только для реализации подхода с раздельным рассмотрением потоков.

Раздел 3.8 представляет описание реализации ThreadCPA.
Основным отличием реализации является отсутствие идентификаторов потока на практике. 
Одним из вариантов решения данной проблемы является использование в качестве идентификаторов имя переменной-описателя потока, однако она может быть переприсвоена даже при активном потоке, что является нетипичной ситуацией, однако не является ошибкой.
Другое важное ограничение заключается в ограниченной поддержке операций типа $thread\_join$, которые не были описаны в теории.

Раздел 3.9 посвящен реализации PredicateCPA.
Анализ предикатов традиционно является самым медленным, то есть именно его операторы тратят большую часть времени анализа программы по сравнению с операторами других CPA.
Поэтому задача повышения его эффективности становится очень актуальной.
В разделе описаны используемые оптимизации, которые используются для повышения скорости анализа различными способами.

Одной из важных оптимизаций является настраиваемое кодирование блоков, которое позволяет сократить количество пересчетов абстракции. 
Однако, подход с раздельным рассмотрением потоков накладывает определенные ограничения на применение этой оптимизации.
Другим важным вопросом является представление эффектов окружения таким образом, чтобы можно было эффективно строить логические формулы, соответствующие примененному эффекту.
Основной проблемой при этом является вычисление корректных SSA-индексов, которые должны соответствовать индексам в состоянии потока.

Уточнение абстракции по контрпримерам также имеет некоторые особенности из-за подхода с раздельным анализом потоков.
В первую очередь возникают проблемы при восстановлении глобального пути, а также при его представлении, так как эффект окружения может не описываться ни одной CFA дугой.
Многие эти проблемы требуют радикального переосмысления механизма уточнения в инфраструктуре CPAchecker, поэтому не все они были решены в рамках данной работы.

В разделе 3.10 описаны основные особенности реализации CompositeCPA, которые заключаются, в основном, в удобной комбинации CPA, которые реализуют подход с раздельным рассмотрением потоков, и тех, которые являются инвариантными к переходам в окружении, а значит, могут не предоставлять расширенное множество операторов. 
Кроме того, в разделе описаны отличия при реализации оператора $strengthen$.

В разделе 3.11 описан UsageCPA, который предоставляет дополнительные возможности для настройки инструмента на целевой код, а также для поиска высокоуровневых гонок с помощью аннотаций.

Раздел 3.12 посвящен еще одной важной оптимизации -- анализу разделяемых данных, который применяется непосредственно перед основным анализом для поиска разделяемых данных.
Так, если какая-то область памяти не является разделяемой, то для нее не будут выданы предупреждения в дальнейшем.
Анализ является консервативным, то есть если не доказано, что какая-то область памяти является локальной, то считается, что она может быть разделяемой.

В разделе 3.13 представлены основные особенности при вычислении состояний гонки при анализе реальных программ.
Важным отличием является активное использование указателей, однако использование анализа алиасов является очень неэффективным.
Кроме того, анализ алиасов требует явной инициализации каждого указателя. Поэтому для решения данной проблемы была использована специализированная модель памяти BnB, основанная на разделении памяти на непересекающиеся регионы по типам.
Кроме того, каждое поле структуры, от которого не брался адрес, выделяется в отдельный регион.
Такая модель памяти позволяет достаточно точно вычислять потенциальные состояния гонки.

Однако сам процесс вычисления устроен сложным образом, так как необходимо сначала восстановить всю информацию о доступах к данным, потерянную из-за применения оптимизации BAM, а затем обеспечить эффективное хранение, поиск и модификацию этой информации.
Для этого применяются различные оптимизации, связанные с выделением приоритетной информации и упорядочивании ее. 

Раздел 3.14 содержит описание процесса уточнения при поиске состояния гонки.
Так как полученная абстракция программы может является аппроксимацией сверху множества состояний программы, возможны ситуации, при которых некоторые важные детали не будут учтены. 
Это приведет к тому, что будет выдано ложное сообщение об ошибке. 
Процесс уточнения позволяет повысить степень уверенности в том, что найденная ошибка является истинной.
Например, может быть проверена локальная достижимость каждого из путей, участвующих в состоянии гонки.
Этот процесс требует достаточно большого количества ресурсов, однако может быть прерван в любой момент.

Основным отличием от классического варианта является то, состояние гонки определяется парой доступов, соответственно, возникает необходимость уточнения пары путей.
Кроме того, так как процесс уточнения запускается после полного построения абстракции, имеется большой выбор состояний для уточнения, а уточнение всех путей подряд приведет к большому количеству однообразных предикатов.
Для решения этой проблемы используются различные эвристики для определения значимости уточнения каждого конкретного пути.

В разделе 3.15 представлено описание формата визуализации результатов.
Для визуализации используется формат GraphML, который уже применяется в других инструментах статической верификации.
В этом разделе описан механизм построения трассы, приводящей к состоянию гонки, а также показана возможность их визуализации.

%Можно сослаться на свои работы в автореферате. Для этого в файле
%\verb!Synopsis/setup.tex! необходимо присвоить положительное значение
%счётчику \verb!\setcounter{usefootcite}{1}!. В таком случае ссылки на
%работы других авторов будут подстрочными.
%\ifnumgreater{\value{usefootcite}}{0}{
%Изложенные в третьей главе результаты опубликованы в~\cite{vakbib1, vakbib2}.
%}{}

В \underline{\textbf{четвертой главе}} приведены результаты экспериментальной оценке предложенного метода.
Сравнение проводилось на множестве задач SV-COMP, множестве задач, подготовленных на основе подсистемы \textit{drivers/net} ОС Linux, а также двух ядрах закрытых операционных систем реального времени.

В разделе 4.1 описана общая схема проведения экспериментов, описаны использованные задачи, конфигурации и машины, на которых производился запуск.

В разделе 4.2 представлены результаты сравнения различных инструментов верификации: CPALockator и участников соревнования SV-COMP.
Threading является реализацией подхода с чередованиями на базе CPAchecker.
Yogar-CBMC и Lazy-CSeq реализуют подходы ограничиваемой проверки моделей и секвенциализации соответственно.

\begin{center}
  \begin{table}[h]\footnotesize \centering
  	\label{table-sv-comp-tools}
    \caption{Запуск на наборе задач SV-COMP}
    \begin{tabular}{ | l | c | c | c | c | c | c |}
      \hline
      		 & \multicolumn{3}{c|}{Другие инструменты} & 		 \\
      Подход         				& Yogar-CBMC 	& Lazy-CSeq  & Threading & CPALockator   \\ \hline
      Вердикт <<ошибка>> 			& 773       	& 811       & 727      & 1028    			\\ 
  \hspace{0.5cm} из них корректных 	& 773       	& 811       & 727      & 805 				\\ 
  \hspace{0.5cm} из них некорректных& 0    		& 0       		& 0      & 223 		     \\ \hline
      Вердикт <<нет ошибки>>  		& 284        	& 256     & 165     & 21      		  \\ 
  \hspace{0.5cm} из них корректных 	& 284        	& 256     & 165   	& 21      		      \\
  \hspace{0.5cm} из них некорректных & 0 			& 0       	& 0         	& 0        \\ \hline
      Анализ не завершен       		& 25        	& 15      & 190     & 33     		 	\\ \hline
      Время CPU (с)   				& 7 000    		& 29 000   & 111 000  & 23 700 			 \\ 
      \hline
    \end{tabular}
  \end{table}
\end{center}

Основные выводы заключаются в том, что CPALockator демонстрирует эффективную работу, однако его точность значительно ниже, чем у других инструментов.
При этом общее время работы одного из инструментов меньше, чем у CPALockator, за счет быстрого решения небольших задач.
Тем не менее, никто из инструментов-участников соревнования SV-COMP не решил те несколько примеров, которые основаны на драйверах ОС Linux, кроме CPALockator.
Таким образом, можно заключить, что CPALockator экспериментально подтверждает то, что он не пропускает ошибок, а также то, что он эффективно решает сложные задачи.

В разделе 4.3 представлены результаты сравнения различных вариантов реализации PredicateCPA: различные варианты оператора $merge$, а также использование оптимизаций.
Результаты показывают, что использование оператора $merge_{Join}$ является предпочтительным для большинства задач.
Среди оптимизаций стоит выделить оптимизацию ABE, которая улучшает эффективность анализа любого исходного кода.
Некоторые другие оптимизации имеет смысл применять при анализе системного программного кода, в то время как на искусственных тестах SV-COMP они значительно ухудшают показатели.
Другие оптимизации позволяют значительно ускорить анализ, однако приводят к появлению новых ложных сообщений об ошибках.

В разделе 4.4 представлены результаты сравнения различных вариантов реализации ThreadCPA.
Эксперименты подтверждают, что расширенный вариант ThreadCPA, инвариантный к переходам в окружении, способен обеспечить сопоставимую точность с вариантом с эффектами окружения.
Тем не менее, простой анализ потоков является достаточным для тех случаев, в которых создание потоков производится искусственным образом в модели окружения.

Различные варианты обработки повторно создаваемого потока также демонстрируют различные результаты в зависимости от целевого исходного кода.
Например, при анализе исходного кода ОС РВ все три способа показывают похожие результаты, в то время как на наборе SV-COMP они проявляют себя совершенно по-разному. 

Общий вывод по результатам заключается в том, что по возможности нужно использовать простой вариант ThreadCPA, который является корректным при некоторых дополнительных предположениях.
Однако, если есть сомнения в выполнении данных предположений для конкретного исходного кода, тогда следует использовать тот вариант, который гарантирует корректность.

В разделе 4.5 приведено сравнение различных вариантов реализации LockCPA.
Сравнение различных вариантов реализации оператора $merge$ не выявило существенных отличий ни на каком наборе задач.
Это демонстрирует невысокую актуальность данного варианта.
Различные варианты оптимизации BAM показывают свою эффективность только на большом объеме исходного кода, однако в этом случае становятся принципиально важными.
Использование уточнения, наоборот, снижает эффективность анализа на любом тестовом наборе, что подтверждает предположение, что затраты на уточнение не перекрывают выгоду от менее точной начальной абстракции.

В разделе 4.6 рассмотрено сравнение вклада в точность и эффективность анализа дополнительных CPA.
Оптимизация BAM в данный момент ограничена только CPA, инвариантными к переходам в окружении.
Результаты демонстрируют ее высокую эффективность, кроме того большие объемы исходного кода могут быть проанализированы только с ее помощью.

Применение анализа разделяемых данных в данной реализации имеет смысл только для решения задачи поиска состояния гонки.
При этом даже для задач на основе драйверов ОС Linux анализ разделяемых данных не показывает существенного улучшения из-за анализа потоков.
Но для ОС РВ анализ разделяемых данных способен существенно снизить количество ложных предупреждений об ошибке.

Анализ предикатов обеспечивает высокую точность, однако для получения легковесного варианта инструмента его можно исключить из конфигурации, это приведет к значительному повышению скорости анализа за счет снижения точности.

В разделе 4.7 представлены результаты поиска известных ошибок в драйверах ОС Linux.
Для этого был проведен анализ исправлений в стабильных версиях ядра Linux, и были найдены 8 коммитов, которые исправляют ошибки, связанные с состоянием гонки.

  \begin{table}[h] \footnotesize \centering
    \caption{Результаты запуска инструмента на известных ошибках в стабильных версиях ядра ОС Linux}
  	\label{table-commits}
    \begin{tabular}{ | l | l | c | l |}
      \hline
      Коммит         	& Результат  & Комментарий \\ \hline
      0e2400e			& $+$   		& 	\\ 
      7357404			& $\pm$   		& 	Спец. конфигурация\\ \hline
      f1a8a3f			& $\mp$   		& Спец. конфигурация; найдена нецелевая ошибка \\ %Nontarget bug was found	\\ 
      1a81087			& $\pm$   		& Найдена нецелевая ошибка \\
      f0c626f			& $\mp$   		& Спец. конфигурация; найдена нецелевая ошибка \\ \hline %Nontarget bug was found	\\ \hline
      aea9dd5			& $-$   		& \\ %Timeout	\\ 
      10ef175			& $-$   		& Таймаут	\\ 
      4036523			& $-$   		& \\ 
      \hline
    \end{tabular}
  \end{table}
  
В двух случаях инструмент находит именно те ошибки, которые исправляются в данных коммитах.
В трех случаях инструмент находит нецелевые ошибки, то есть реальные, но не те, которые исправляются в коммитах.
Еще в трех случаях ошибка не была найдена из-за исчерпания лимита времени.
При этом для трех задач потребовалось использовать специальную конфигурацию инструмента.
Таким образом, подтверждается, что инструмент CPALockator позволяет не пропустить ошибку при некоторых предположениях.

В разделе 4.8 приведены результаты анализа основных причин ложных срабатываний инструмента.

\begin{table}[h] \footnotesize \centering
    \caption{Анализ предупреждений в модулях ядра ОС Linux}
  	\label{table-unsafes}
    \begin{tabular}{ | l | c | l |}
      \hline
      Количество &	Процент    	& Описание \\ \hline
      41		&	48\%     	& Истинных предупреждений	\\ 
      25		&	29\%     	& Неточность подготовки задачи	\\ 
      19		&	22\%     	& Неточность метода	\\ \hline
      \hspace{1cm}8   &	9\%     	& Неточность модели памяти	\\ 
      \hspace{1cm}7	  &	8\%     	& Специфика ядра ОС (прерывания)  \\
      \hspace{1cm}4	  &	5\%     	& Неточность отдельных типов анализа 	\\ 
      \hline
    \end{tabular}
  \end{table}

Как и следовало ожидать, основные причины ложных срабатываний связаны с некорректной подготовкой верификационной задачи сторонним компонентом и с неточной моделью памяти.
Менее значимые причины включают в себя неточности различных компонентов инструмента: анализ примитивов синхронизации, анализ предикатов, анализ разделяемых данных и~т.~д.

В разделе 4.9 сформулированы основные выводы по результатам всех экспериментов: основные сценарии использования различных конфигураций и оптимизаций в зависимости от целевого исходного кода.
Кроме того, показаны основные проблемные места на основе анализа причин ложных срабатываний и результатов поиска известных ошибок.

%Результаты демонстрируют возможности инструмента CPALockator по его гибкой настройки.
%В качестве набора небольших программ был выбран открытый тестовый набор sv-comp, на нем CPALockator показал достаточно точные результаты. 
%Было получено некоторое количество ложных предупреждений об ошибке, но ни одной реальной ошибки не было пропущено, что подтверждает корректность разработанного метода.
%При этом, конечно, другие методы статической верификации способны выдавать меньшее количество ложных предупреждений на таком наборе небольших рукописных программ.
%Для проверки масштабируемости инструмента были выбраны несколько модулей операционной системы Linux с заранее известными ошибками.
%Более половины из этих ошибок были успешно обнаружены инструментами, при этом в оставшихся случаях верификация завершилась из-за нехватки вычислительных ресурсов.
%Если снизить еще снизить требования к точности, все реальные ошибки успешно обнаруживаются, хотя при этом появляется некоторое количество ложных предупреждений.
%
%Гибкая настройка требований к ресурсам позволяет использовать инструмент для проверки достаточно больших программных систем, содержащих сотни тысяч строк кода и проводить их анализ за минуты.
%При необходимости для каждой конкретной задачи можно выбрать свой баланс между качеством и требуемыми ресурсами, в зависимости от поставленной цели. 

В \underline{\textbf{заключении}} приведены основные результаты работы, которые заключаются в следующем:
\input{common/concl}


%\newpage
%При использовании пакета \verb!biblatex! список публикаций автора по теме
%диссертации формируется в разделе <<\publications>>\ файла
%\verb!../common/characteristic.tex!  при помощи команды \verb!\nocite! 

\ifdefmacro{\microtypesetup}{\microtypesetup{protrusion=false}}{} % не рекомендуется применять пакет микротипографики к автоматически генерируемому списку литературы
  \renewcommand{\bibname}{\large \authorbibtitle}
  \nocite{*}
  \insertbiblioauthor           % Подключаем Bib-базы
\ifdefmacro{\microtypesetup}{\microtypesetup{protrusion=true}}{}

