
{\actuality} Информационные технологии являются важной составляющей инфраструктуры современного общества.
Они позволяют автоматизировать различные процессы жизнедеятельности человека и обеспечить возможность коммуникации.
%В настоящее время невозможно представить себе высокотехнологичное производство или сервис услуг, которые бы обходились без использования информационных технологий.
%Более того, сейчас активно развиваются технологии, которые позволяют автоматизировать бытовые потребности человека.
%К таким технологиям относится «интернет вещей» (англ. Internet of Things, IoT).
%Это означает, что жизнь человека становится все более и более зависимой от программных систем.
%Для эффективного использования многоядерных систем широко используется многопоточное программное обеспечение, в том числе и системное программное обеспечение.
Таким образом, задача повышения производительности компьютерных систем становится чрезвычайно важной.
Развитие технологий многоядерности и многопоточности являются важнейшими направлениями решения данной задачи.
Например, в ядре операционной системы может параллельно выполняться большое число (несколько десятков) совершенно различных активностей: обработчики прерываний, системные вызовы от пользовательских программ, драйверы внешних устройств, внутренние службы ядра, например, планировщик.
Только за счет использования многопоточности современные системы могут обеспечивать необходимые показатели производительности.
%

%Информационные системы непрерывно развиваются и усложняются. 
%С ростом сложности программных продуктов росло и количество ошибок в них.
%Повышение роли программного обеспечения в жизнедеятельности человека приводит к увеличению величины последствий от отказа или некорректного поведения.
%Некоторые ошибки способны сильно исказить правильное выполнение программы и привести к серьезным последствиям.
%В 2017 году компания Coverity опубликовала очередной отчет, в котором были приведены результаты исследования изучения 760 млн строк кода.
%В среднем, в программном продукте содержится около 1.4 ошибок на 1000 строк кода.
%Это число ошибок значительно вырасло по сравнению с отчетами предыдущих лет.
%Таким образом, число проблем в проекте размером миллион строк кода исчисляется тысячами.
%Степень критичности ошибки также зависит и от той области, в которой применяется программное обеспечение.
%Ошибки в программных системах, используемых в авиации или на атомных электростанциях, могут привести к значительным человеческим жертвам или колоссальным финансовым затратам.
%Известно множество случаев, в которых ошибки в программном обеспечении приводили к серьезным последствиям, например, случаи с аппаратом лучевой терапии Therac-25 и с космическим аппаратом 
%Phobos\citeinsynopsis{Leveson:1995}.
%Таким образом, с момента возникновения первых вычислительных систем перед людьми всегда стояла задача проверки правильности программы. 

%Под верификацией будем понимать проверку соответствия одних создаваемых в ходе разработки и сопровождения программного обеспечения сущностей другим, ранее созданным или используемым в качестве исходных данных, а также соответствие этих сущностей и процессов их разработки правилам и стандартам [4]. В качестве сущностей могут выступать непосредственно программы, модели, документы и др.
%Существует несколько методов верификации: экспертиза, статический анализ, формальные методы, динамические методы, синтетические методы. 

%Поэтому с самого начала развития информатики развиваются и совершенствуются методы проверки программ и доказательства их корректности. Их уже достаточно много: от ручных математических доказательств, до динамического тестирования. Они прошли долгий путь от формальных математических доказательств, которые были доступны только специалистам, обладающим хорошим математическим образованием, до прикладных инструментов, понятных даже инженерам и разработчикам прикладного программного обеспечения.

%Развитие параллельных вычислений привело к быстрому разрастанию кода, который предполагает параллельное исполнение.
%%Цифры? 
%Параллельные алгоритмы позволяют более эффективно использовать доступные вычислительные ресурсы.
%Основной сложностью таких алгоритмов является обеспечение синхронизации между потоками и корректным использованием разделяемых ресурсов.
%В связи с этим появляются новые типы ошибок, характерные только для параллельно исполняемого кода. 

В дополнение к ошибкам, которые встречаются во всех видах программного обеспечения, многопоточные программы могут содержать специфические ошибки, связанные с параллельным выполнением: например, состояния <<гонки>> и состояния взаимной блокировки.
В общем случае состоянием гонки называют ситуацию, при которой поведение программы зависит от порядка или времени выполнения некоторых неконтролируемых событий.
Важное уточнение заключается в том, что такое выполнение не всегда является ошибкой.
Проблемы возникают тогда, когда разработчик не предусматривает некоторое из возможных поведений программы.
Часто рассматривают более узкий класс -- <<состояния гонки по данным>>. Эта ситуация возникает при одновременном доступе к данным из разных потоков (процессов).
%Здесь и далее не будем различать потоки и процессы, так как их различия не имеют отношения к теме работы.
Одновременное чтение данных из нескольких потоков не может привести к недетерминированным результатам, и состояния гонки по данным становятся опасными в случае, если имеет место хотя бы один доступ на запись в разделяемую область памяти.
%Пример!
В этом случае результирующее значение переменной зависит от порядка выполнения инструкций, а в параллельно выполняемом коде, в общем случае, последовательность выполнения инструкций не определена. 

%Стоит упомянуть о высокоуровневых состояниях гонки по данным.
%Такие состояния гонки по данным отличается тем, что доступ производится к разным разделяемым данным, которые тем не менее являются семантически связанными.
%Например, это может быть реализация сложных структур данных, таких как двусвязные списки, деревья, графы и т. п.
%В случае модификации такой структуры данных должна быть обеспечена атомарность, в противном случае, данные могут стать неконсистентными, например, не нарушится целостность списка. 
 
Состояния взаимных блокировок являются вторым большим классом ошибок в многопоточных программах.
Они возникают при некорректном использовании блокирующих механизмов синхронизации.
В этом случае некоторые потоки системы находятся в ожидании некоторого разблокирующего действия от других потоков и не могут продолжить свое выполнение. 

Оба класса ошибок так или иначе связаны с некорректной синхронизацией параллельно выполняющихся потоков.
Поиск и исправление таких ошибок, связанных с параллельным исполнением кода, затруднен из-за необходимости анализировать все возможные сценарии взаимодействия потоков, а также из-за случайного характера их проявления, так как ошибка может проявляться очень редко.
Это связано с тем, что для проявления ошибки необходимы некоторая конкретная последовательность и порядок действий различных потоков. 
В системном программном обеспечении могут использоваться не только обыкновенные примитивы синхронизации, но и некоторые специальные, например, запреты прерываний. 
Для упрощения поиска таких ошибок рарабатываются различные автоматизированные подходы.
Но для анализа системного программного обеспечения, например, операционных систем, требуются специализированные инструменты, которые будут учитывать их особенности.

Обычно выделяют два класса подходов к анализу программ: статические, которые проводят анализ исходного кода программы, и динамические, которые анализируют поведение программы в процессе ее выполнения.
Каждый имеет свои достоинства и недостатки, например, методы динамического анализа обычно характеризуются высоким уровнем истинных предупреждений, в то время как статические методы позволяют покрыть больший объем кода.
На данный момент не существует универсального подхода для анализа программ.

В большинстве прикладных пользовательских программ может быть достаточно провести тщательное тестирование, возможно, с помощью инструментов динамического анализа, чтобы проверить основные сценарии поведения программы.
%Однако, такое тестирование не дает гарантий корректного поведения даже при тех же самых условиях и входных данных, что для пользовательских приложений является приемлемым вариантом.
В случае же критически важного ПО, в т.ч. системного программного обеспечения, цена пропущенной ошибки может быть слишком велика.
Кроме того, некоторые сценарии поведения программы слишком сложно воспроизвести при реальном выполнении.
Устройство системного программного обеспечения отличается от прикладных программ, что затрудняет анализ, так как далеко не все методы принимают во внимание специфику системного программного обеспечения.
Поэтому применения только динамического анализа недостаточно, необходимо применять и методы статического анализа.

Методы статической верификации способны обеспечить доказательство отсутствия ошибок в некоторых заранее заданных предположениях, но при этом традиционно испытывают сложности при масштабировании на большие объемы исходного кода.
Тем не менее, такие методы показывают высокую точность, что является важной особенностью при анализе такого программного обеспечения, к которому предъявляются высокие требования качества.
%Развитие подобных методов позволит повысить качество системного программного обеспечения.
Таким образом, разработка масштабируемого метода статической верификации для поиска состояний гонки является актуальной задачей.

%В ядре операционной системы может одновременно выполняться большое число (несколько десятков) совершенно различных функций: обработчики прерываний, системные вызовы от пользовательских программ, внутренние службы ядра, например, планировщик, драйвера внешних устройств.
%Для синхронизации всех этих функций используются не только обыкновенные примитивы синхронизации, но и специальные низкоуровневые, которые характерны только для системного программного обеспечения, например, запреты прерываний и планирования. 
%Различные исследования показывают, что ошибки, связанные с параллельным выполнением, в системном программном обеспечении являются достаточно многочисленными, например, к ним относятся около 20\% всех ошибок в файловых
%системах~\citeinsynopsis{Palix11}.
%
%Верификация многопоточных программ всегда являлась более сложной задачей, чем верификация последовательных программ.
%Точное вычисление всех возможных чередований (англ. interleavings), приводит к комбинаторному взрыву числа состояний.
%Поэтому, большинство инструментов статической верификации применяют арзличные техники оптимизации: редукция частичных порядков (англ. partial order reduction)~\citeinsynopsis{Abdulla:2014},\citeinsynopsis{Godefroid:1996}, абстракция счетчика (англ. counter abstraction)~\citeinsynopsis{Basler:2009} и другие.
%Тем не менее, большинство современных инструментов статической верификации плохо масштабируются на промышленное программное обеспечение.
%Этот факт подтверждается соревнованием по статической верификации~\citeinsynopsis{svcomp19}.
%Задачи из категории «многопоточность», основанные на драйверах операционной системы Linux вызывают значительные сложности для всех инструментов статической верификации.
%
%Противоположностью методам проверки моделей являются методы статического анализа, которые нацелены на быстрый поиск ошибок без какой-либо уверенности в финальном вердикте.
%Такие инструменты применяют различные фильтры и эвристики для ускорения анализа и поэтому не могут гарантировать корректность, то есть отсутствие ошибок.
%В данной работе представлен подход к статической верификации многопоточного программного обеспечения, который позволяет легко настраивать баланс между скоростью и точностью проводимого анализа. Кроме того, он легко нацеливается на конкретную задачу.

%В частности, анализ типовых ошибок, исправленных за год в ядре операционной системы Linux, показал, что ошибки, связанные с состоянием гонки образуют самый многочисленный класс и составляют около 17\% от всех 
%\ifsynopsis
%ошибок.
%\else
%ошибок~\cite{commit_analysis_12}.
%\fi

%Таким образом, задача поиска ошибок синхронизации в ядрах операционных систем, в том числе, состояний гонки по данным, является важной и актуальной задачей.

%\ifsynopsis
%%Этот абзац появляется только в~автореферате.
%\else
%
%%Динамический анализ системного программного обеспечения не обеспечивает должного качества для применения целевого ПО в критически важных областях. В таких случаях необходимо применение формальных методов верификации. Основной сложностью данного подхода является высокая сложность точного моделирования системного программного обеспечения, так как неизбежно возникает проблема комбинаторного взрыва. Тем не менее, сейчас активно применяется формальная верификация для доказательств корректности отдельных подсистем (модулей) программной системы с формулировкой требований на корректное использование его интерфейсов другими частями системы.
%
%Даже при анализе одного потока сложной программной системы возникают сложности с анализом циклов, битовых операций, адресной арифметики. 
%На сколько учитывать окружение и другие потоки?
%\fi

% {\progress} 
% Этот раздел должен быть отдельным структурным элементом по
% ГОСТ, но он, как правило, включается в описание актуальности
% темы. Нужен он отдельным структурынм элемементом или нет ---
% смотрите другие диссертации вашего совета, скорее всего не нужен.

{\aimandtasks} Целью данной работы является разработка метода поиска состояний гонок, который будет масштабироваться на большие объемы кода, будет обладать приемлемым уровнем ложных предупреждений и будет учитывать специфику ядра операционных систем.

Для~достижения поставленной цели необходимо было решить следующие {\tasks}:
\begin{enumerate}
  \item Разработать метод поиска состояний гонки, на основе подхода с раздельным анализом потоков.
  \item Разработать алгоритм построения окружения потока, который будет обладать конфигурируемостью и масштабироваться на большие объемы исходного кода, и доказать его корректность.
  \item Модернизировать алгоритм адаптивного статического анализа (англ. Configurable Program Analysis, CPA) с целью обеспечения возможности выполнять верификацию программого обеспчения с раздельным анализом потоков и доказать его корректность.
  \item Реализовать разработанные алгоритмы.
  \item Провести эксперименты и сравнить результаты с другими инструментами статической верификации.
\end{enumerate}

{\novelty}
\begin{enumerate}
  \item Метод поиска состояний гонки на основе раздельного анализа потоков, использующий средства абстракции состояний и переходов для управления точностью и ресурсоемкостью верификации.
  \item Алгоритм построения окружения потока, который позволяет гибко настраивать уровень абстракции над взаимодействием потоков, и доказательство его корректности.
  \item Новый алгоритм, который является обобщением существующего алгоритма cтатической верификации программ при помощи метода CPA, расширяющий типовой набор CPA-анализаторов средствами верификации многопоточных программ с раздельным анализом потоков, и доказательство его корректности.
  %\item Были проведены запуски инструмента на модулях ядра операционной системы Linux, а также на двух операционных системах реального времени;
\end{enumerate}

{\influence} Развитие метода адаптивного статического анализа для обеспечения возможности его использования вместе с подходом раздельного анализа потоков является важным теоретичеким вкладом в развитие программной инженерии.
Разработка нового алгоритма построения окружения потока является важным развитием подхода с раздельным анализом потоков для обеспечения возможности применения к большому объему исходного кода.
Практическим результатом данного исследования является множество найденных ошибок как в операционных системах реального времени, так и в драйверах устройств операционной системы Linux.

{\methods} При проведении работы были использованы как теоретические методы исследования (анализ, формализация, абстрагирование), так и практические (эксперименты, сравнение).

{\defpositions}
%\textbf{Положения, выносимые на публичное представление}
\begin{enumerate}
\item Метод поиска состояний гонки на основе раздельного анализа потоков, использующий средства абстракции состояний и переходов для управления точностью и ресурсоемкостью верификации. 
\item Алгоритм построения окружения потока и верификации многопоточных программ с помощью подхода с раздельным анализом потоков и доказательство его корректности.
\item Обобщение алгоритма статической верификации программ при помощи
метода CPA, расширяющий типовой набор CPA-анализаторов средствами верификации многопоточных программ с раздельным анализом потоков, и доказательство его корректности.
\end{enumerate}

%{\reliability} полученных результатов обеспечивается \ldots \ Результаты находятся в соответствии с результатами, полученными другими авторами.

{\probation}
Основные результаты работы докладывались~на:
\begin{itemize}
  % \item Весенний коллоквиум молодых исследователей в области программной инженерии (SYRCoSE: Spring Young Researchers Colloquium on Software Engineering), Санкт-Петербург, 2014 г.;
  % \item Научно-исследовательский семинар лаборатории «Software and Computational Systems Lab» Университета Пассау, Германия, 2014 г.
  \item Международная научно-практическая конференция <<Инструменты и методы анализа программ>> (TMPA: Tools and Methods for Program Analysis), Кострома, 2014 г.
  \item Международный семинар разработчиков CPAchecker, Москва, 2015 г.
  \item Летняя научная школа компании Microsoft (Microsoft Summer School), Кэмбридж, Англия, 2015 г.
  \item Научно-практическая Открытая конференция ИСП РАН, Москва, 2016 г.
  \item Научно-исследовательский семинар лаборатории <<Software and Computational Systems Lab>> Университета Пассау, Германия, 2016 г.
  \item Международная научно-практическая конференция <<Инструменты и методы анализа программ>> (TMPA: Tools and Methods for Program Analysis), Москва, 2017 г.
  \item Международный семинар разработчиков CPAchecker, Падерборн, Германия, 2017 г.
  \item Международный семинар разработчиков CPAchecker, Москва, Россия, 2018 г.
  \item Соревнования по статической верификации SV-COMP, Прага, Чехия, 2019 г.
  \item Международный семинар разработчиков CPAchecker, Фрауенинзель, Германия, 2019 г.
  \item Семинар <<Математические вопросы информатики>> Мехмат МГУ, Москва, Россия, 2019 г.
\end{itemize}

\publications\ Основные результаты по теме диссертации изложены в 8 печатных изданиях~\cite{theoryVAK,KernelRaces,LockatorScalable,lockatorVAK,lockatorVAK2,TMPA2017,lockatorSyrcose,lockatorTMPA}, 
    6 из которых изданы в журналах, рекомендованных ВАК~\cite{theoryVAK,lockatorVAK,lockatorVAK2,KernelRaces,LockatorScalable,TMPA2017}, из них 3 находится в базе Scopus~\cite{KernelRaces,LockatorScalable,TMPA2017},
    2 "--- в тезисах докладов~\cite{lockatorSyrcose,lockatorTMPA}.

В статье~\cite{lockatorVAK} автором описана основная идея метода (глава 3) и его реализация (глава 5).
В статье~\cite{lockatorVAK2} автором написаны разделы, посвященные общей идее метода (глава 3), его реализации (глава 4), процессу уточнения (глава 5) и анализу потоков (глава 6).
В статье~\cite{TMPA2017} автором написаны разделы, посвященные разработанному методу и его реализации (главы 3--6).
В статье~\cite{lockatorSyrcose} автором написаны разделы, в которых описывается ключевые особенности метода (главы 3--5).
В статье~\cite{lockatorTMPA} автором написаны разделы, посвященные разработанному методу (главы 3--5).
В статье~\cite{LockatorScalable} автором написаны разделы, описывающие теорию масштабируемого метода (главы 3--8).

{\contribution} Все представленные в диссертации результаты получены лично автором.