
{\actuality} Информационные технологии являются важной составляющей инфраструктуры современного общества.
Они позволяют автоматизировать различные процессы жизнедеятельности человека и обеспечить возможность коммуникации.
%В настоящее время невозможно представить себе высокотехнологичное производство или сервис услуг, которые бы обходились без использования информационных технологий.
%Более того, сейчас активно развиваются технологии, которые позволяют автоматизировать бытовые потребности человека.
%К таким технологиям относится «интернет вещей» (англ. Internet of Things, IoT).
%Это означает, что жизнь человека становится все более и более зависимой от программных систем.
%Для эффективного использования многоядерных систем широко используется многопоточное программное обеспечение, в том числе и системное программное обеспечение.
Таким образом, задача повышения производительности компьютерных систем становится чрезвычайно важной.
Развитие технологий многоядерности и многопоточности являются важнейшими направлениями решения данной задачи.
Например, в ядре операционной системы может одновременно выполняться большое число (несколько десятков) совершенно различных активностей: обработчики прерываний, системные вызовы от пользовательских программ, внутренние службы ядра, например, планировщик, драйвера внешних устройств.
Только за счет использования многопоточности современные системы могут обеспечивать необходимые показатели скорости и производительности.
%

%Информационные системы непрерывно развиваются и усложняются. 
%С ростом сложности программных продуктов росло и количество ошибок в них.
%Повышение роли программного обеспечения в жизнедеятельности человека приводит к увеличению величины последствий от отказа или некорректного поведения.
%Некоторые ошибки способны сильно исказить правильное выполнение программы и привести к серьезным последствиям.
%В 2017 году компания Coverity опубликовала очередной отчет, в котором были приведены результаты исследования изучения 760 млн строк кода.
%В среднем, в программном продукте содержится около 1.4 ошибок на 1000 строк кода.
%Это число ошибок значительно вырасло по сравнению с отчетами предыдущих лет.
%Таким образом, число проблем в проекте размером миллион строк кода исчисляется тысячами.
%Степень критичности ошибки также зависит и от той области, в которой применяется программное обеспечение.
%Ошибки в программных системах, используемых в авиации или на атомных электростанциях, могут привести к значительным человеческим жертвам или колоссальным финансовым затратам.
%Известно множество случаев, в которых ошибки в программном обеспечении приводили к серьезным последствиям, например, случаи с аппаратом лучевой терапии Therac-25 и с космическим аппаратом 
%Phobos\citeinsynopsis{Leveson:1995}.
%Таким образом, с момента возникновения первых вычислительных систем перед людьми всегда стояла задача проверки правильности программы. 

%Под верификацией будем понимать проверку соответствия одних создаваемых в ходе разработки и сопровождения программного обеспечения сущностей другим, ранее созданным или используемым в качестве исходных данных, а также соответствие этих сущностей и процессов их разработки правилам и стандартам [4]. В качестве сущностей могут выступать непосредственно программы, модели, документы и др.
%Существует несколько методов верификации: экспертиза, статический анализ, формальные методы, динамические методы, синтетические методы. 

%Поэтому с самого начала развития информатики развиваются и совершенствуются методы проверки программ и доказательства их корректности. Их уже достаточно много: от ручных математических доказательств, до динамического тестирования. Они прошли долгий путь от формальных математических доказательств, которые были доступны только специалистам, обладающим хорошим математическим образованием, до прикладных инструментов, понятных даже инженерам и разработчикам прикладного программного обеспечения.

%Развитие параллельных вычислений привело к быстрому разрастанию кода, который предполагает параллельное исполнение.
%%Цифры? 
%Параллельные алгоритмы позволяют более эффективно использовать доступные вычислительные ресурсы.
%Основной сложностью таких алгоритмов является обеспечение синхронизации между потоками и корректным использованием разделяемых ресурсов.
%В связи с этим появляются новые типы ошибок, характерные только для параллельно исполняемого кода. 

В дополнении к ошибкам, которые встречаются во всех видах программного обеспечения, многопоточные программы могут содержать специфические ошибки, связанные с параллельным выполнением: например, состояния взаимной блокировки и состояния <<гонки>>.
В общем случае состоянием гонки называют ситуацию, при которой поведение программы зависит от порядка или времени выполнения некоторых неконтролируемых событий.
Важное уточнение заключается в том, что такое выполнение не всегда является ошибкой.
Проблемы возникают тогда, когда разработчик не предусматривает некоторое из возможных поведений программы.
Часто рассматривают более узкий класс -- <<состояния гонки по данным>>. Эта ситуация возникает при одновременном доступе к данным из разных потоков (процессов).
%Здесь и далее не будем различать потоки и процессы, так как их различия не имеют отношения к теме работы.
Состояния гонки по данным становятся опасными в случае, если имеет место хотя бы один доступ на запись в разделяемую область памяти.
%Пример!
В этом случае результирующее значение переменной зависит от порядка выполнения инструкций, а в параллельно выполняемом коде, в общем случае, последовательность выполнения инструкций не определена. 

%Стоит упомянуть о высокоуровневых состояниях гонки по данным.
%Такие состояния гонки по данным отличается тем, что доступ производится к разным разделяемым данным, которые тем не менее являются семантически связанными.
%Например, это может быть реализация сложных структур данных, таких как двусвязные списки, деревья, графы и т. п.
%В случае модификации такой структуры данных должна быть обеспечена атомарность, в противном случае, данные могут стать неконсистентными, например, не нарушится целостность списка. 
 
Состояния взаимных блокировок являются вторым большим классом ошибок в многопоточных программах.
Они возникают при некорректном использовании блокирующих механизмов синхронизации.
В этом случае все потоки системы находятся в ожидании некоторого разблокирующего действия от других потоков и не могут продолжить свое выполнение. 

Оба класса ошибок так или иначе связаны с некорректной синхронизацией параллельно выполняющихся потоков.
Такие ошибки, связанные с параллельным исполнением кода, искать и исправлять гораздо сложнее, чем ошибки в последовательном коде, так как необходимо анализировать все возможные сценарии взаимодействия потоков.
Кроме того, поиск и исправление таких ошибок осложняется случайным характером их проявлений, ошибка может проявляться очень редко.
Это связано с тем, что для проявления ошибки необходимы некоторая конкретная последовательность и порядок действий различных потоков. 
В системном программном обеспечении могут использоваться не только обыкновенные примитивы синхронизации, но и специальные низкоуровневые, например, запреты прерываний и планирования. 
Таким образом, обнаружить ошибку, связанную с некорректной синхронизацией потоков, вручную практически невозможно, поэтому для их поиска используются различные автоматизированные подходы.
Кроме этого, для анализа системного программного обеспечения, например, операционных систем, требутся специализированные инструменты, которые будут учитывать их особенности.

Обычно выделяют два класса подходов к анализу программ: статические, которые проводят анализ исходного кода программы, и динамические, которые анализируют поведение программы в процессе ее выполнения.
Каждый имеет свои достоинства и недостатки, например, методы динамического анализа обычно характеризуются высоким уровнем истинных предупреждений, в то время как статические методы позволяют покрыть больший объем кода.
На данный момент не существует универсального подхода для анализа программ.

В прикладных пользовательских программах может быть достаточно провести тщательное тестирование, возможно, с помощью инструментов динамического анализа, чтобы проверить основные сценарии поведения программы.
%Однако, такое тестирование не дает гарантий корректного поведения даже при тех же самых условиях и входных данных, что для пользовательских приложений является приемлемым вариантом.
В случае же системного программного обеспечения цена пропущенной ошибки может быть слишком велика.
Кроме того, некоторые сценарии поведения программы слишком сложно воспроизвести при реальном выполнении.
Устройство системного программного обеспечения отличается от прикладных программ, что затрудняет анализ, так как далеко не все методы принимают во внимание специфику системного программного обеспечения.
Поэтому применение только динамического анализу становится недостаточным, и в дополнение к ним применяются методы статической верификации.

Методы статической верификации способны обеспечить доказательство отсутствия ошибок в некоторых заранее заданных предположениях, но при этом традиционно испытывают сложности при масштабировании на большие объемы исходного кода.
Тем не менее, такие методы показывают высокую точность, что является важной особенностью при анализе такого программного обеспечения, к которому предъявляются высокие требования качества.
%Развитие подобных методов позволит повысить качество системного программного обеспечения.
Таким образом, разработка масштабируемого метода статической верификации для поиска состояний гонки является актуальной задачей.

%В ядре операционной системы может одновременно выполняться большое число (несколько десятков) совершенно различных функций: обработчики прерываний, системные вызовы от пользовательских программ, внутренние службы ядра, например, планировщик, драйвера внешних устройств.
%Для синхронизации всех этих функций используются не только обыкновенные примитивы синхронизации, но и специальные низкоуровневые, которые характерны только для системного программного обеспечения, например, запреты прерываний и планирования. 
%Различные исследования показывают, что ошибки, связанные с параллельным выполнением, в системном программном обеспечении являются достаточно многочисленными, например, к ним относятся около 20\% всех ошибок в файловых
%системах~\citeinsynopsis{Palix11}.
%
%Верификация многопоточных программ всегда являлась более сложной задачей, чем верификация последовательных программ.
%Точное вычисление всех возможных чередований (англ. interleavings), приводит к комбинаторному взрыву числа состояний.
%Поэтому, большинство инструментов статической верификации применяют арзличные техники оптимизации: редукция частичных порядков (англ. partial order reduction)~\citeinsynopsis{Abdulla:2014},\citeinsynopsis{Godefroid:1996}, абстракция счетчика (англ. counter abstraction)~\citeinsynopsis{Basler:2009} и другие.
%Тем не менее, большинство современных инструментов статической верификации плохо масштабируются на промышленное программное обеспечение.
%Этот факт подтверждается соревнованием по статической верификации~\citeinsynopsis{svcomp19}.
%Задачи из категории «многопоточность», основанные на драйверах операционной системы Linux вызывают значительные сложности для всех инструментов статической верификации.
%
%Противоположностью методам проверки моделей являются методы статического анализа, которые нацелены на быстрый поиск ошибок без какой-либо уверенности в финальном вердикте.
%Такие инструменты применяют различные фильтры и эвристики для ускорения анализа и поэтому не могут гарантировать корректность, то есть отсутствие ошибок.
%В данной работе представлен подход к статической верификации многопоточного программного обеспечения, который позволяет легко настраивать баланс между скоростью и точностью проводимого анализа. Кроме того, он легко нацеливается на конкретную задачу.

%В частности, анализ типовых ошибок, исправленных за год в ядре операционной системы Linux, показал, что ошибки, связанные с состоянием гонки образуют самый многочисленный класс и составляют около 17\% от всех 
%\ifsynopsis
%ошибок.
%\else
%ошибок~\cite{commit_analysis_12}.
%\fi

%Таким образом, задача поиска ошибок синхронизации в ядрах операционных систем, в том числе, состояний гонки по данным, является важной и актуальной задачей.

%\ifsynopsis
%%Этот абзац появляется только в~автореферате.
%\else
%
%%Динамический анализ системного программного обеспечения не обеспечивает должного качества для применения целевого ПО в критически важных областях. В таких случаях необходимо применение формальных методов верификации. Основной сложностью данного подхода является высокая сложность точного моделирования системного программного обеспечения, так как неизбежно возникает проблема комбинаторного взрыва. Тем не менее, сейчас активно применяется формальная верификация для доказательств корректности отдельных подсистем (модулей) программной системы с формулировкой требований на корректное использование его интерфейсов другими частями системы.
%
%Даже при анализе одного потока сложной программной системы возникают сложности с анализом циклов, битовых операций, адресной арифметики. 
%На сколько учитывать окружение и другие потоки?
%\fi

% {\progress} 
% Этот раздел должен быть отдельным структурным элементом по
% ГОСТ, но он, как правило, включается в описание актуальности
% темы. Нужен он отдельным структурынм элемементом или нет ---
% смотрите другие диссертации вашего совета, скорее всего не нужен.

{\aim} данной работы является разработка метода поиска состояний гонок, который будет масштабироваться на большие объемы кода, будет обладать приемлемым уровнем ложных предупреждений и будет учитывать специфику ядра операционных систем.

Для~достижения поставленной цели необходимо было решить следующие {\tasks}:
\begin{enumerate}
  \item Разработать общий алгоритм, позволяющий реализовать подход к верификации программного обеспечения с раздельным анализом потоков, и доказать его корректность;
  \item Разработать метод поиска состояний гонки, как частный случай общего алгоритма, который может эффективно применяться к большим объемам исходного кода, и доказать его корректность;
  \item Реализовать разработанные алгоритмы;
  \item Провести эксперименты и сравнить результаты с другими инструментами статической верификации;
\end{enumerate}

{\novelty}
\begin{enumerate}
  \item Был предложен новый алгоритм, который является обобщением существующего алгоритма CPA, и доказана его корректность;
  \item Был предложен частный случай обобщенного алгоритма, который реализует подход с раздельным анализом потоков, и доказана его корректность;
  \item Разработан метод поиска состояний гонки и доказана его корректность;
  %\item Были проведены запуски инструмента на модулях ядра операционной системы Linux, а также на двух операционных системах реального времени;
\end{enumerate}

%{\influence} \ldots

%{\methods} \ldots

%{\defpositions}
\textbf{Положения, выносимые на публичное представление}
\begin{enumerate}
  \item Обобщенный алгоритм анализа программ, позволяющий использовать различные виды анализа, и доказательство его корректности;
  \item Алгоритм, позволяющий проводить раздельный анализ потоков многопоточных программ, и доказательство его корректности;
  \item Метод поиска состояний гонки в многопоточных программах.
\end{enumerate}

%{\reliability} полученных результатов обеспечивается \ldots \ Результаты находятся в соответствии с результатами, полученными другими авторами.

{\probation}
Основные результаты работы докладывались~на:
\begin{itemize}
  % \item Весенний коллоквиум молодых исследователей в области программной инженерии (SYRCoSE: Spring Young Researchers Colloquium on Software Engineering), Санкт-Петербург, 2014 г.;
  % \item Научно-исследовательский семинар лаборатории «Software and Computational Systems Lab» Университета Пассау, Германия, 2014 г.
  \item Международная научно-практическая конференция <<Инструменты и методы анализа программ>> (TMPA: Tools and Methods for Program Analysis), Кострома, 2014 г.
  \item Международный семинар разработчиков CPAchecker, Москва, 2015 г.
  \item Летняя научная школа компании Microsoft (Microsoft Summer School), Кэмбридж, Англия, 2015 г.
  \item Научно-практическая Открытая конференция ИСП РАН, Москва, 2016 г.
  \item Научно-исследовательский семинар лаборатории <<Software and Computational Systems Lab>> Университета Пассау, Германия, 2016 г.
  \item Международная научно-практическая конференция <<Инструменты и методы анализа программ>> (TMPA: Tools and Methods for Program Analysis), Москва, 2017 г.
  \item Международный семинар разработчиков CPAchecker, Падерборн, Германия, 2017 г.
  \item Международный семинар разработчиков CPAchecker, Москва, Россия, 2018 г.
  \item Соревнования по статической верификации SV-COMP, Прага, Чехия, 2019 г.
  \item Международный семинар разработчиков CPAchecker, Фрауенинзель, Германия, 2019 г.
  \item Семинар <<Математические вопросы информатики>> Мехмат МГУ, Москва, Россия, 2019 г.
\end{itemize}

% {\contribution} Автор принимал активное участие \ldots

\publications\ Основные результаты по теме диссертации изложены в 6 печатных изданиях~\cite{lockatorVAK,lockatorVAK2,TMPA2017,theoryVAK,lockatorSyrcose,lockatorTMPA}, 
    4 из которых изданы в журналах, рекомендованных ВАК~\cite{lockatorVAK,lockatorVAK2,TMPA2017,theoryVAK}, из них 1 находится в базе Scopus~\cite{TMPA2017},
    2 "--- в тезисах докладов~\cite{lockatorSyrcose,lockatorTMPA}.

В статье~\cite{lockatorVAK} автором описана основная идея метода (глава 3) и его реализация (глава 5).
В статье~\cite{lockatorVAK2} автором написаны разделы, посвященные общей идее метода (глава 3), его реализации (глава 4), процессу уточнения (глава 5) и анализу потоков (глава 6).
В статье~\cite{TMPA2017} автором написаны разделы, посвященные разработанному методу и его реализации (главы 3--6).
В статье~\cite{lockatorSyrcose} автором написаны разделы, в которых описывается ключевые особенности метода (главы 3--5).
В статье~\cite{lockatorTMPA} автором написаны разделы, посвященные разработанному методу (главы 3--5).

